{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useIntersection = useIntersection;\n\nvar _react = require(\"react\");\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection({\n  rootRef,\n  rootMargin,\n  disabled\n}) {\n  const isDisabled = disabled || !hasIntersectionObserver;\n  const unobserve = (0, _react).useRef();\n  const [visible, setVisible] = (0, _react).useState(false);\n  const [root, setRoot] = (0, _react).useState(rootRef ? rootRef.current : null);\n  const setRef = (0, _react).useCallback(el => {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, isVisible => isVisible && setVisible(isVisible), {\n        root,\n        rootMargin\n      });\n    }\n  }, [isDisabled, root, rootMargin, visible]);\n  const resetVisible = (0, _react).useCallback(() => {\n    setVisible(false);\n  }, []);\n  (0, _react).useEffect(() => {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        const idleCallback = (0, _requestIdleCallback).requestIdleCallback(() => setVisible(true));\n        return () => (0, _requestIdleCallback).cancelIdleCallback(idleCallback);\n      }\n    }\n  }, [visible]);\n  (0, _react).useEffect(() => {\n    if (rootRef) setRoot(rootRef.current);\n  }, [rootRef]);\n  return [setRef, visible, resetVisible];\n}\n\nfunction observe(element, callback, options) {\n  const {\n    id,\n    observer,\n    elements\n  } = createObserver(options);\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements.delete(element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers.delete(id);\n      let index = idList.findIndex(obj => obj.root === id.root && obj.margin === id.margin);\n\n      if (index > -1) {\n        idList.splice(index, 1);\n      }\n    }\n  };\n}\n\nconst observers = new Map();\nconst idList = [];\n\nfunction createObserver(options) {\n  const id = {\n    root: options.root || null,\n    margin: options.rootMargin || ''\n  };\n  let existing = idList.find(obj => obj.root === id.root && obj.margin === id.margin);\n  let instance;\n\n  if (existing) {\n    instance = observers.get(existing);\n  } else {\n    instance = observers.get(id);\n    idList.push(id);\n  }\n\n  if (instance) {\n    return instance;\n  }\n\n  const elements = new Map();\n  const observer = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const callback = elements.get(entry.target);\n      const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id,\n    observer,\n    elements\n  });\n  return instance;\n}\n\nif (typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) {\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"sources":["../../client/use-intersection.tsx"],"names":["hasIntersectionObserver","IntersectionObserver","useIntersection","rootRef","rootMargin","disabled","isDisabled","unobserve","useRef","visible","setVisible","useState","root","setRoot","current","setRef","useCallback","el","undefined","tagName","observe","isVisible","resetVisible","useEffect","idleCallback","requestIdleCallback","cancelIdleCallback","element","callback","options","id","observer","elements","createObserver","set","delete","size","disconnect","observers","index","idList","findIndex","obj","margin","splice","Map","existing","find","instance","get","push","entries","forEach","entry","target","isIntersecting","intersectionRatio"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.useIntersection = useIntersection;\nvar _react = require(\"react\");\nvar _requestIdleCallback = require(\"./request-idle-callback\");\nconst hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\nfunction useIntersection({ rootRef , rootMargin , disabled  }) {\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const unobserve = (0, _react).useRef();\n    const [visible, setVisible] = (0, _react).useState(false);\n    const [root, setRoot] = (0, _react).useState(rootRef ? rootRef.current : null);\n    const setRef = (0, _react).useCallback((el)=>{\n        if (unobserve.current) {\n            unobserve.current();\n            unobserve.current = undefined;\n        }\n        if (isDisabled || visible) return;\n        if (el && el.tagName) {\n            unobserve.current = observe(el, (isVisible)=>isVisible && setVisible(isVisible)\n            , {\n                root,\n                rootMargin\n            });\n        }\n    }, [\n        isDisabled,\n        root,\n        rootMargin,\n        visible\n    ]);\n    const resetVisible = (0, _react).useCallback(()=>{\n        setVisible(false);\n    }, []);\n    (0, _react).useEffect(()=>{\n        if (!hasIntersectionObserver) {\n            if (!visible) {\n                const idleCallback = (0, _requestIdleCallback).requestIdleCallback(()=>setVisible(true)\n                );\n                return ()=>(0, _requestIdleCallback).cancelIdleCallback(idleCallback)\n                ;\n            }\n        }\n    }, [\n        visible\n    ]);\n    (0, _react).useEffect(()=>{\n        if (rootRef) setRoot(rootRef.current);\n    }, [\n        rootRef\n    ]);\n    return [\n        setRef,\n        visible,\n        resetVisible\n    ];\n}\nfunction observe(element, callback, options) {\n    const { id , observer , elements  } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            let index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin\n            );\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || ''\n    };\n    let existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin\n    );\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n    } else {\n        instance = observers.get(id);\n        idList.push(id);\n    }\n    if (instance) {\n        return instance;\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    observers.set(id, instance = {\n        id,\n        observer,\n        elements\n    });\n    return instance;\n}\n\nif (typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) {\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=use-intersection.js.map"]},"metadata":{},"sourceType":"script"}
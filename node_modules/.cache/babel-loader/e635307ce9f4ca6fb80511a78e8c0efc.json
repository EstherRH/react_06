{"ast":null,"code":"var _s = $RefreshSig$();\n\n// useFetch - CustomHook (124)\n// nuevo!!\n//   es el componente que va a trabajar con la info de useFetch\n//  los dos hooks se comunican\nimport React, { useEffect, useState } from \"react\"; // ( url ) --> pedimos la url -->  https://www.breakingbadapi.com/api/quotes/1\n\nexport const useFetch1 = url => {\n  _s();\n\n  // esta es la data que se coloca al final en el return\n  // se le pasa la info: data, loading y error\n  // esta es la data que se regresa abajo ( en el return )\n  const [state, setState] = useState({\n    data: null,\n    isLoading: true,\n    // saber cuándo se está cargando\n    hasError: null // maneja si hay un error. está en null porque no hay ningún error\n\n  }); // esta es la petición\n  // es una función asíncrona\n\n  const getFetch = async () => {\n    // vuelve a poner el loading en true\n    // si se vuelve a llamar al getFetch\n    setState({ ...state,\n      isLoading: true\n    }); // hacemos la petición fetch:\n    // se almacena la respuesta:\n\n    const resp = await fetch(url); // llamamos al fetch y le pasamos la url como argumento\n    // data: el await de la respuesta\n\n    const data = await resp.json(); // cuando tenemos la data, llamamos al set State\n    // regresa un nuevo estado\n    // si se manda el setState a un objeto, hay que pasarle todas las propiedades\n    // se manda llamar el setState\n\n    setState({\n      isLoading: false,\n      // en false, porque ya se terminó de cargar\n      hasError: null,\n      // porque no hay ningún error\n      data\n    });\n  };\n\n  useEffect(() => {\n    getFetch(); // aquí se dispara la petición fetch\n  }, [url]); // deps: [url] --> le estamos diciendo: ejecútate solo cuando la url cambia\n\n  return state;\n};\n\n_s(useFetch1, \"dqAbi2sgDtC7wshkpkxTPKac0VE=\");","map":{"version":3,"sources":["/Volumes/ALOY/Front/6_React/retshe/src/hooks/useFetch1.js"],"names":["React","useEffect","useState","useFetch1","url","state","setState","data","isLoading","hasError","getFetch","resp","fetch","json"],"mappings":";;AACA;AACA;AAEA;AACA;AAEA,OAAOA,KAAP,IAAeC,SAAf,EAA0BC,QAA1B,QAAyC,OAAzC,C,CAEA;;AACA,OAAO,MAAMC,SAAS,GAAKC,GAAF,IAAW;AAAA;;AAEhC;AACA;AACA;AACA,QAAM,CAACC,KAAD,EAAQC,QAAR,IAAoBJ,QAAQ,CAAC;AAC/BK,IAAAA,IAAI,EAAE,IADyB;AAE/BC,IAAAA,SAAS,EAAE,IAFoB;AAEd;AACjBC,IAAAA,QAAQ,EAAE,IAHqB,CAGf;;AAHe,GAAD,CAAlC,CALgC,CAYhC;AACA;;AACA,QAAMC,QAAQ,GAAG,YAAY;AAEzB;AACA;AACAJ,IAAAA,QAAQ,CAAE,EACN,GAAGD,KADG;AAENG,MAAAA,SAAS,EAAE;AAFL,KAAF,CAAR,CAJyB,CASzB;AACA;;AACA,UAAMG,IAAI,GAAG,MAAMC,KAAK,CAACR,GAAD,CAAxB,CAXyB,CAWM;AAC/B;;AACA,UAAMG,IAAI,GAAG,MAAMI,IAAI,CAACE,IAAL,EAAnB,CAbyB,CAezB;AACA;AACA;AACA;;AACAP,IAAAA,QAAQ,CAAC;AACLE,MAAAA,SAAS,EAAE,KADN;AACa;AAClBC,MAAAA,QAAQ,EAAE,IAFL;AAEY;AACjBF,MAAAA;AAHK,KAAD,CAAR;AAKH,GAxBD;;AA0BAN,EAAAA,SAAS,CAAC,MAAM;AACZS,IAAAA,QAAQ,GADI,CACA;AACf,GAFQ,EAEN,CAACN,GAAD,CAFM,CAAT,CAxCgC,CA4ChC;;AAEA,SAAOC,KAAP;AACH,CA/CM;;GAAMF,S","sourcesContent":["\n// useFetch - CustomHook (124)\n// nuevo!!\n\n//   es el componente que va a trabajar con la info de useFetch\n//  los dos hooks se comunican\n\nimport React, {useEffect, useState} from \"react\";\n\n// ( url ) --> pedimos la url -->  https://www.breakingbadapi.com/api/quotes/1\nexport const useFetch1 = ( url ) => {\n\n    // esta es la data que se coloca al final en el return\n    // se le pasa la info: data, loading y error\n    // esta es la data que se regresa abajo ( en el return )\n    const [state, setState] = useState({\n        data: null,\n        isLoading: true, // saber cuándo se está cargando\n        hasError: null  // maneja si hay un error. está en null porque no hay ningún error\n    });\n\n\n    // esta es la petición\n    // es una función asíncrona\n    const getFetch = async () => {\n\n        // vuelve a poner el loading en true\n        // si se vuelve a llamar al getFetch\n        setState( {\n            ...state,\n            isLoading: true,\n        });\n\n        // hacemos la petición fetch:\n        // se almacena la respuesta:\n        const resp = await fetch(url); // llamamos al fetch y le pasamos la url como argumento\n        // data: el await de la respuesta\n        const data = await resp.json();\n\n        // cuando tenemos la data, llamamos al set State\n        // regresa un nuevo estado\n        // si se manda el setState a un objeto, hay que pasarle todas las propiedades\n        // se manda llamar el setState\n        setState({\n            isLoading: false, // en false, porque ya se terminó de cargar\n            hasError: null,  // porque no hay ningún error\n            data\n        })\n    }\n\n    useEffect(() => {\n        getFetch(); // aquí se dispara la petición fetch\n    }, [url])\n\n    // deps: [url] --> le estamos diciendo: ejecútate solo cuando la url cambia\n\n    return state;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\n\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../shared/lib/router/utils/get-asset-path-from-route\"));\n\nvar _requestIdleCallback = require(\"./request-idle-callback\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\n\n\nconst MS_MAX_IDLE_DELAY = 3800;\n\nfunction withFuture(key, map, generator) {\n  let entry = map.get(key);\n\n  if (entry) {\n    if ('future' in entry) {\n      return entry.future;\n    }\n\n    return Promise.resolve(entry);\n  }\n\n  let resolver;\n  const prom = new Promise(resolve => {\n    resolver = resolve;\n  });\n  map.set(key, entry = {\n    resolve: resolver,\n    future: prom\n  });\n  return generator ? generator() // eslint-disable-next-line no-sequences\n  .then(value => (resolver(value), value)).catch(err => {\n    map.delete(key);\n    throw err;\n  }) : prom;\n}\n\nfunction hasPrefetch(link) {\n  try {\n    link = document.createElement('link');\n    return (// detect IE11 since it supports prefetch but isn't detected\n      // with relList.support\n      !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch')\n    );\n  } catch (e) {\n    return false;\n  }\n}\n\nconst canPrefetch = hasPrefetch();\n\nfunction prefetchViaDom(href, as, link) {\n  return new Promise((res, rej) => {\n    const selector = `\n      link[rel=\"prefetch\"][href^=\"${href}\"],\n      link[rel=\"preload\"][href^=\"${href}\"],\n      script[src^=\"${href}\"]`;\n\n    if (document.querySelector(selector)) {\n      return res();\n    }\n\n    link = document.createElement('link'); // The order of property assignment here is intentional:\n\n    if (as) link.as = as;\n    link.rel = `prefetch`;\n    link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n    link.onload = res;\n    link.onerror = rej; // `href` should always be last:\n\n    link.href = href;\n    document.head.appendChild(link);\n  });\n}\n\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\n\nfunction markAssetError(err) {\n  return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\n\nfunction isAssetError(err) {\n  return err && ASSET_LOAD_ERROR in err;\n}\n\nfunction appendScript(src, script) {\n  return new Promise((resolve, reject) => {\n    script = document.createElement('script'); // The order of property assignment here is intentional.\n    // 1. Setup success/failure hooks in case the browser synchronously\n    //    executes when `src` is set.\n\n    script.onload = resolve;\n\n    script.onerror = () => reject(markAssetError(new Error(`Failed to load script: ${src}`))); // 2. Configure the cross-origin attribute before setting `src` in case the\n    //    browser begins to fetch.\n\n\n    script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN; // 3. Finally, set the source and inject into the DOM in case the child\n    //    must be appended for fetching to start.\n\n    script.src = src;\n    document.body.appendChild(script);\n  });\n} // We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\n\n\nlet devBuildPromise; // Resolve a promise that times out after given amount of milliseconds.\n\nfunction resolvePromiseWithTimeout(p, ms, err) {\n  return new Promise((resolve, reject) => {\n    let cancelled = false;\n    p.then(r => {\n      // Resolved, cancel the timeout\n      cancelled = true;\n      resolve(r);\n    }).catch(reject); // We wrap these checks separately for better dead-code elimination in\n    // production bundles.\n\n    if (process.env.NODE_ENV === 'development') {\n      (devBuildPromise || Promise.resolve()).then(() => {\n        (0, _requestIdleCallback).requestIdleCallback(() => setTimeout(() => {\n          if (!cancelled) {\n            reject(err);\n          }\n        }, ms));\n      });\n    }\n\n    if (process.env.NODE_ENV !== 'development') {\n      (0, _requestIdleCallback).requestIdleCallback(() => setTimeout(() => {\n        if (!cancelled) {\n          reject(err);\n        }\n      }, ms));\n    }\n  });\n}\n\nfunction getClientBuildManifest() {\n  if (self.__BUILD_MANIFEST) {\n    return Promise.resolve(self.__BUILD_MANIFEST);\n  }\n\n  const onBuildManifest = new Promise(resolve => {\n    // Mandatory because this is not concurrent safe:\n    const cb = self.__BUILD_MANIFEST_CB;\n\n    self.__BUILD_MANIFEST_CB = () => {\n      resolve(self.__BUILD_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\n\nfunction getMiddlewareManifest() {\n  if (self.__MIDDLEWARE_MANIFEST) {\n    return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n  }\n\n  const onMiddlewareManifest = new Promise(resolve => {\n    const cb = self.__MIDDLEWARE_MANIFEST_CB;\n\n    self.__MIDDLEWARE_MANIFEST_CB = () => {\n      resolve(self.__MIDDLEWARE_MANIFEST);\n      cb && cb();\n    };\n  });\n  return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\n\nfunction getFilesForRoute(assetPrefix, route) {\n  if (process.env.NODE_ENV === 'development') {\n    return Promise.resolve({\n      scripts: [assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js'))],\n      // Styles are handled by `style-loader` in development:\n      css: []\n    });\n  }\n\n  return getClientBuildManifest().then(manifest => {\n    if (!(route in manifest)) {\n      throw markAssetError(new Error(`Failed to lookup route: ${route}`));\n    }\n\n    const allFiles = manifest[route].map(entry => assetPrefix + '/_next/' + encodeURI(entry));\n    return {\n      scripts: allFiles.filter(v => v.endsWith('.js')),\n      css: allFiles.filter(v => v.endsWith('.css'))\n    };\n  });\n}\n\nfunction createRouteLoader(assetPrefix) {\n  const entrypoints = new Map();\n  const loadedScripts = new Map();\n  const styleSheets = new Map();\n  const routes = new Map();\n\n  function maybeExecuteScript(src) {\n    // With HMR we might need to \"reload\" scripts when they are\n    // disposed and readded. Executing scripts twice has no functional\n    // differences\n    if (process.env.NODE_ENV !== 'development') {\n      let prom = loadedScripts.get(src);\n\n      if (prom) {\n        return prom;\n      } // Skip executing script if it's already in the DOM:\n\n\n      if (document.querySelector(`script[src^=\"${src}\"]`)) {\n        return Promise.resolve();\n      }\n\n      loadedScripts.set(src, prom = appendScript(src));\n      return prom;\n    } else {\n      return appendScript(src);\n    }\n  }\n\n  function fetchStyleSheet(href) {\n    let prom = styleSheets.get(href);\n\n    if (prom) {\n      return prom;\n    }\n\n    styleSheets.set(href, prom = fetch(href).then(res => {\n      if (!res.ok) {\n        throw new Error(`Failed to load stylesheet: ${href}`);\n      }\n\n      return res.text().then(text => ({\n        href: href,\n        content: text\n      }));\n    }).catch(err => {\n      throw markAssetError(err);\n    }));\n    return prom;\n  }\n\n  return {\n    whenEntrypoint(route) {\n      return withFuture(route, entrypoints);\n    },\n\n    onEntrypoint(route, execute) {\n      (execute ? Promise.resolve().then(() => execute()).then(exports => ({\n        component: exports && exports.default || exports,\n        exports: exports\n      }), err => ({\n        error: err\n      })) : Promise.resolve(undefined)).then(input => {\n        const old = entrypoints.get(route);\n\n        if (old && 'resolve' in old) {\n          if (input) {\n            entrypoints.set(route, input);\n            old.resolve(input);\n          }\n        } else {\n          if (input) {\n            entrypoints.set(route, input);\n          } else {\n            entrypoints.delete(route);\n          } // when this entrypoint has been resolved before\n          // the route is outdated and we want to invalidate\n          // this cache entry\n\n\n          routes.delete(route);\n        }\n      });\n    },\n\n    loadRoute(route, prefetch) {\n      return withFuture(route, routes, () => {\n        let devBuildPromiseResolve;\n\n        if (process.env.NODE_ENV === 'development') {\n          devBuildPromise = new Promise(resolve => {\n            devBuildPromiseResolve = resolve;\n          });\n        }\n\n        return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(({\n          scripts,\n          css\n        }) => {\n          return Promise.all([entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)), Promise.all(css.map(fetchStyleSheet))]);\n        }).then(res => {\n          return this.whenEntrypoint(route).then(entrypoint => ({\n            entrypoint,\n            styles: res[1]\n          }));\n        }), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(({\n          entrypoint,\n          styles\n        }) => {\n          const res = Object.assign({\n            styles: styles\n          }, entrypoint);\n          return 'error' in entrypoint ? entrypoint : res;\n        }).catch(err => {\n          if (prefetch) {\n            // we don't want to cache errors during prefetch\n            throw err;\n          }\n\n          return {\n            error: err\n          };\n        }).finally(() => {\n          return devBuildPromiseResolve === null || devBuildPromiseResolve === void 0 ? void 0 : devBuildPromiseResolve();\n        });\n      });\n    },\n\n    prefetch(route) {\n      // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n      // License: Apache 2.0\n      let cn;\n\n      if (cn = navigator.connection) {\n        // Don't prefetch if using 2G or if Save-Data is enabled.\n        if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n      }\n\n      return getFilesForRoute(assetPrefix, route).then(output => Promise.all(canPrefetch ? output.scripts.map(script => prefetchViaDom(script, 'script')) : [])).then(() => {\n        (0, _requestIdleCallback).requestIdleCallback(() => this.loadRoute(route, true).catch(() => {}));\n      }).catch( // swallow prefetch errors\n      () => {});\n    }\n\n  };\n}\n\nif (typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) {\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}","map":{"version":3,"sources":["../../client/route-loader.ts"],"names":["MS_MAX_IDLE_DELAY","withFuture","key","map","generator","entry","get","future","Promise","resolve","resolver","prom","set","then","value","catch","err","delete","hasPrefetch","link","document","createElement","window","MSInputMethodContext","documentMode","relList","supports","canPrefetch","prefetchViaDom","href","as","res","rej","selector","querySelector","rel","crossOrigin","process","env","__NEXT_CROSS_ORIGIN","onload","onerror","head","appendChild","ASSET_LOAD_ERROR","Symbol","markAssetError","Object","defineProperty","isAssetError","appendScript","src","script","reject","Error","body","devBuildPromise","resolvePromiseWithTimeout","p","ms","cancelled","r","NODE_ENV","requestIdleCallback","setTimeout","getClientBuildManifest","self","__BUILD_MANIFEST","onBuildManifest","cb","__BUILD_MANIFEST_CB","getMiddlewareManifest","__MIDDLEWARE_MANIFEST","onMiddlewareManifest","__MIDDLEWARE_MANIFEST_CB","getFilesForRoute","assetPrefix","route","scripts","encodeURI","getAssetPathFromRoute","css","manifest","allFiles","filter","v","endsWith","createRouteLoader","entrypoints","Map","loadedScripts","styleSheets","routes","maybeExecuteScript","fetchStyleSheet","fetch","ok","text","content","whenEntrypoint","onEntrypoint","execute","exports","component","default","error","undefined","input","old","loadRoute","prefetch","devBuildPromiseResolve","all","has","entrypoint","styles","assign","finally","cn","navigator","connection","saveData","test","effectiveType","output"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.markAssetError = markAssetError;\nexports.isAssetError = isAssetError;\nexports.getClientBuildManifest = getClientBuildManifest;\nexports.getMiddlewareManifest = getMiddlewareManifest;\nexports.createRouteLoader = createRouteLoader;\nvar _getAssetPathFromRoute = _interopRequireDefault(require(\"../shared/lib/router/utils/get-asset-path-from-route\"));\nvar _requestIdleCallback = require(\"./request-idle-callback\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    let entry = map.get(key);\n    if (entry) {\n        if ('future' in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    let resolver;\n    const prom = new Promise((resolve)=>{\n        resolver = resolve;\n    });\n    map.set(key, entry = {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator()// eslint-disable-next-line no-sequences\n    .then((value)=>(resolver(value), value)\n    ).catch((err)=>{\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement('link');\n        return(// detect IE11 since it supports prefetch but isn't detected\n        // with relList.support\n        (!!window.MSInputMethodContext && !!document.documentMode) || link.relList.supports('prefetch'));\n    } catch (e) {\n        return false;\n    }\n}\nconst canPrefetch = hasPrefetch();\nfunction prefetchViaDom(href, as, link) {\n    return new Promise((res, rej)=>{\n        const selector = `\n      link[rel=\"prefetch\"][href^=\"${href}\"],\n      link[rel=\"preload\"][href^=\"${href}\"],\n      script[src^=\"${href}\"]`;\n        if (document.querySelector(selector)) {\n            return res();\n        }\n        link = document.createElement('link');\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = `prefetch`;\n        link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n        link.onload = res;\n        link.onerror = rej;\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction appendScript(src, script) {\n    return new Promise((resolve, reject)=>{\n        script = document.createElement('script');\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = ()=>reject(markAssetError(new Error(`Failed to load script: ${src}`)))\n        ;\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise((resolve, reject)=>{\n        let cancelled = false;\n        p.then((r)=>{\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (process.env.NODE_ENV === 'development') {\n            (devBuildPromise || Promise.resolve()).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms)\n                );\n            });\n        }\n        if (process.env.NODE_ENV !== 'development') {\n            (0, _requestIdleCallback).requestIdleCallback(()=>setTimeout(()=>{\n                    if (!cancelled) {\n                        reject(err);\n                    }\n                }, ms)\n            );\n        }\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    const onBuildManifest = new Promise((resolve)=>{\n        // Mandatory because this is not concurrent safe:\n        const cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = ()=>{\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\nfunction getMiddlewareManifest() {\n    if (self.__MIDDLEWARE_MANIFEST) {\n        return Promise.resolve(self.__MIDDLEWARE_MANIFEST);\n    }\n    const onMiddlewareManifest = new Promise((resolve)=>{\n        const cb = self.__MIDDLEWARE_MANIFEST_CB;\n        self.__MIDDLEWARE_MANIFEST_CB = ()=>{\n            resolve(self.__MIDDLEWARE_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onMiddlewareManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client middleware manifest')));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (process.env.NODE_ENV === 'development') {\n        return Promise.resolve({\n            scripts: [\n                assetPrefix + '/_next/static/chunks/pages' + encodeURI((0, _getAssetPathFromRoute).default(route, '.js')), \n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then((manifest)=>{\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(`Failed to lookup route: ${route}`));\n        }\n        const allFiles = manifest[route].map((entry)=>assetPrefix + '/_next/' + encodeURI(entry)\n        );\n        return {\n            scripts: allFiles.filter((v)=>v.endsWith('.js')\n            ),\n            css: allFiles.filter((v)=>v.endsWith('.css')\n            )\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    const entrypoints = new Map();\n    const loadedScripts = new Map();\n    const styleSheets = new Map();\n    const routes = new Map();\n    function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (process.env.NODE_ENV !== 'development') {\n            let prom = loadedScripts.get(src);\n            if (prom) {\n                return prom;\n            }\n            // Skip executing script if it's already in the DOM:\n            if (document.querySelector(`script[src^=\"${src}\"]`)) {\n                return Promise.resolve();\n            }\n            loadedScripts.set(src, prom = appendScript(src));\n            return prom;\n        } else {\n            return appendScript(src);\n        }\n    }\n    function fetchStyleSheet(href) {\n        let prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href).then((res)=>{\n            if (!res.ok) {\n                throw new Error(`Failed to load stylesheet: ${href}`);\n            }\n            return res.text().then((text)=>({\n                    href: href,\n                    content: text\n                })\n            );\n        }).catch((err)=>{\n            throw markAssetError(err);\n        }));\n        return prom;\n    }\n    return {\n        whenEntrypoint (route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint (route, execute) {\n            (execute ? Promise.resolve().then(()=>execute()\n            ).then((exports)=>({\n                    component: exports && exports.default || exports,\n                    exports: exports\n                })\n            , (err)=>({\n                    error: err\n                })\n            ) : Promise.resolve(undefined)).then((input)=>{\n                const old = entrypoints.get(route);\n                if (old && 'resolve' in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute (route, prefetch) {\n            return withFuture(route, routes, ()=>{\n                let devBuildPromiseResolve;\n                if (process.env.NODE_ENV === 'development') {\n                    devBuildPromise = new Promise((resolve)=>{\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then(({ scripts , css  })=>{\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet)), \n                    ]);\n                }).then((res)=>{\n                    return this.whenEntrypoint(route).then((entrypoint)=>({\n                            entrypoint,\n                            styles: res[1]\n                        })\n                    );\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(`Route did not complete loading: ${route}`))).then(({ entrypoint , styles  })=>{\n                    const res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return 'error' in entrypoint ? entrypoint : res;\n                }).catch((err)=>{\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(()=>{\n                    return devBuildPromiseResolve === null || devBuildPromiseResolve === void 0 ? void 0 : devBuildPromiseResolve();\n                });\n            });\n        },\n        prefetch (route) {\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            let cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then((output)=>Promise.all(canPrefetch ? output.scripts.map((script)=>prefetchViaDom(script, 'script')\n                ) : [])\n            ).then(()=>{\n                (0, _requestIdleCallback).requestIdleCallback(()=>this.loadRoute(route, true).catch(()=>{})\n                );\n            }).catch(// swallow prefetch errors\n            ()=>{});\n        }\n    };\n}\n\nif (typeof exports.default === 'function' || (typeof exports.default === 'object' && exports.default !== null)) {\n  Object.assign(exports.default, exports);\n  module.exports = exports.default;\n}\n\n//# sourceMappingURL=route-loader.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = resolveRewrites;\n\nvar _pathMatch = require(\"./path-match\");\n\nvar _prepareDestination = require(\"./prepare-destination\");\n\nvar _normalizeTrailingSlash = require(\"../../../../client/normalize-trailing-slash\");\n\nvar _normalizeLocalePath = require(\"../../i18n/normalize-locale-path\");\n\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\n\nvar _router = require(\"../router\");\n\nfunction resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {\n  let matchedPage = false;\n  let externalDest = false;\n  let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n  let fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _router).delBasePath(parsedAs.pathname), locales).pathname);\n  let resolvedHref;\n\n  const handleRewrite = rewrite => {\n    const matcher = (0, _pathMatch).getPathMatch(rewrite.source, {\n      removeUnnamedParams: true,\n      strict: true\n    });\n    let params = matcher(parsedAs.pathname);\n\n    if (rewrite.has && params) {\n      const hasParams = (0, _prepareDestination).matchHas({\n        headers: {\n          host: document.location.hostname\n        },\n        cookies: document.cookie.split('; ').reduce((acc, item) => {\n          const [key, ...value] = item.split('=');\n          acc[key] = value.join('=');\n          return acc;\n        }, {})\n      }, rewrite.has, parsedAs.query);\n\n      if (hasParams) {\n        Object.assign(params, hasParams);\n      } else {\n        params = false;\n      }\n    }\n\n    if (params) {\n      if (!rewrite.destination) {\n        // this is a proxied rewrite which isn't handled on the client\n        externalDest = true;\n        return true;\n      }\n\n      const destRes = (0, _prepareDestination).prepareDestination({\n        appendParamsToQuery: true,\n        destination: rewrite.destination,\n        params: params,\n        query: query\n      });\n      parsedAs = destRes.parsedDestination;\n      asPath = destRes.newUrl;\n      Object.assign(query, destRes.parsedDestination.query);\n      fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _router).delBasePath(asPath), locales).pathname);\n\n      if (pages.includes(fsPathname)) {\n        // check if we now match a page as this means we are done\n        // resolving the rewrites\n        matchedPage = true;\n        resolvedHref = fsPathname;\n        return true;\n      } // check if we match a dynamic-route, if so we break the rewrites chain\n\n\n      resolvedHref = resolveHref(fsPathname);\n\n      if (resolvedHref !== asPath && pages.includes(resolvedHref)) {\n        matchedPage = true;\n        return true;\n      }\n    }\n  };\n\n  let finished = false;\n\n  for (let i = 0; i < rewrites.beforeFiles.length; i++) {\n    // we don't end after match in beforeFiles to allow\n    // continuing through all beforeFiles rewrites\n    handleRewrite(rewrites.beforeFiles[i]);\n  }\n\n  matchedPage = pages.includes(fsPathname);\n\n  if (!matchedPage) {\n    if (!finished) {\n      for (let i = 0; i < rewrites.afterFiles.length; i++) {\n        if (handleRewrite(rewrites.afterFiles[i])) {\n          finished = true;\n          break;\n        }\n      }\n    } // check dynamic route before processing fallback rewrites\n\n\n    if (!finished) {\n      resolvedHref = resolveHref(fsPathname);\n      matchedPage = pages.includes(resolvedHref);\n      finished = matchedPage;\n    }\n\n    if (!finished) {\n      for (let i = 0; i < rewrites.fallback.length; i++) {\n        if (handleRewrite(rewrites.fallback[i])) {\n          finished = true;\n          break;\n        }\n      }\n    }\n  }\n\n  return {\n    asPath,\n    parsedAs,\n    matchedPage,\n    resolvedHref,\n    externalDest\n  };\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/resolve-rewrites.ts"],"names":["resolveRewrites","asPath","pages","rewrites","query","resolveHref","locales","matchedPage","externalDest","parsedAs","parseRelativeUrl","fsPathname","removePathTrailingSlash","normalizeLocalePath","delBasePath","pathname","resolvedHref","handleRewrite","rewrite","matcher","getPathMatch","source","removeUnnamedParams","strict","params","has","hasParams","matchHas","headers","host","document","location","hostname","cookies","cookie","split","reduce","acc","item","key","value","join","Object","assign","destination","destRes","prepareDestination","appendParamsToQuery","parsedDestination","newUrl","includes","finished","i","beforeFiles","length","afterFiles","fallback"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = resolveRewrites;\nvar _pathMatch = require(\"./path-match\");\nvar _prepareDestination = require(\"./prepare-destination\");\nvar _normalizeTrailingSlash = require(\"../../../../client/normalize-trailing-slash\");\nvar _normalizeLocalePath = require(\"../../i18n/normalize-locale-path\");\nvar _parseRelativeUrl = require(\"./parse-relative-url\");\nvar _router = require(\"../router\");\nfunction resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {\n    let matchedPage = false;\n    let externalDest = false;\n    let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n    let fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _router).delBasePath(parsedAs.pathname), locales).pathname);\n    let resolvedHref;\n    const handleRewrite = (rewrite)=>{\n        const matcher = (0, _pathMatch).getPathMatch(rewrite.source, {\n            removeUnnamedParams: true,\n            strict: true\n        });\n        let params = matcher(parsedAs.pathname);\n        if (rewrite.has && params) {\n            const hasParams = (0, _prepareDestination).matchHas({\n                headers: {\n                    host: document.location.hostname\n                },\n                cookies: document.cookie.split('; ').reduce((acc, item)=>{\n                    const [key, ...value] = item.split('=');\n                    acc[key] = value.join('=');\n                    return acc;\n                }, {})\n            }, rewrite.has, parsedAs.query);\n            if (hasParams) {\n                Object.assign(params, hasParams);\n            } else {\n                params = false;\n            }\n        }\n        if (params) {\n            if (!rewrite.destination) {\n                // this is a proxied rewrite which isn't handled on the client\n                externalDest = true;\n                return true;\n            }\n            const destRes = (0, _prepareDestination).prepareDestination({\n                appendParamsToQuery: true,\n                destination: rewrite.destination,\n                params: params,\n                query: query\n            });\n            parsedAs = destRes.parsedDestination;\n            asPath = destRes.newUrl;\n            Object.assign(query, destRes.parsedDestination.query);\n            fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath((0, _router).delBasePath(asPath), locales).pathname);\n            if (pages.includes(fsPathname)) {\n                // check if we now match a page as this means we are done\n                // resolving the rewrites\n                matchedPage = true;\n                resolvedHref = fsPathname;\n                return true;\n            }\n            // check if we match a dynamic-route, if so we break the rewrites chain\n            resolvedHref = resolveHref(fsPathname);\n            if (resolvedHref !== asPath && pages.includes(resolvedHref)) {\n                matchedPage = true;\n                return true;\n            }\n        }\n    };\n    let finished = false;\n    for(let i = 0; i < rewrites.beforeFiles.length; i++){\n        // we don't end after match in beforeFiles to allow\n        // continuing through all beforeFiles rewrites\n        handleRewrite(rewrites.beforeFiles[i]);\n    }\n    matchedPage = pages.includes(fsPathname);\n    if (!matchedPage) {\n        if (!finished) {\n            for(let i = 0; i < rewrites.afterFiles.length; i++){\n                if (handleRewrite(rewrites.afterFiles[i])) {\n                    finished = true;\n                    break;\n                }\n            }\n        }\n        // check dynamic route before processing fallback rewrites\n        if (!finished) {\n            resolvedHref = resolveHref(fsPathname);\n            matchedPage = pages.includes(resolvedHref);\n            finished = matchedPage;\n        }\n        if (!finished) {\n            for(let i = 0; i < rewrites.fallback.length; i++){\n                if (handleRewrite(rewrites.fallback[i])) {\n                    finished = true;\n                    break;\n                }\n            }\n        }\n    }\n    return {\n        asPath,\n        parsedAs,\n        matchedPage,\n        resolvedHref,\n        externalDest\n    };\n}\n\n//# sourceMappingURL=resolve-rewrites.js.map"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.default = void 0;\n\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\n\nvar _routeLoader = require(\"../../../client/route-loader\");\n\nvar _script = require(\"../../../client/script\");\n\nvar _isError = _interopRequireWildcard(require(\"../../../lib/is-error\"));\n\nvar _denormalizePagePath = require(\"../page-path/denormalize-page-path\");\n\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\n\nvar _mitt = _interopRequireDefault(require(\"../mitt\"));\n\nvar _utils = require(\"../utils\");\n\nvar _isDynamic = require(\"./utils/is-dynamic\");\n\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\n\nvar _querystring = require(\"./utils/querystring\");\n\nvar _resolveRewrites = _interopRequireDefault(require(\"./utils/resolve-rewrites\"));\n\nvar _routeMatcher = require(\"./utils/route-matcher\");\n\nvar _routeRegex = require(\"./utils/route-regex\");\n\nvar _getMiddlewareRegex = require(\"./utils/get-middleware-regex\");\n\nvar _formatUrl = require(\"./utils/format-url\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nlet detectDomainLocale;\n\nif (process.env.__NEXT_I18N_SUPPORT) {\n  detectDomainLocale = require('../i18n/detect-domain-locale').detectDomainLocale;\n}\n\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\n\nfunction buildCancellationError() {\n  return Object.assign(new Error('Route Cancelled'), {\n    cancelled: true\n  });\n}\n\nfunction addPathPrefix(path, prefix) {\n  if (!path.startsWith('/') || !prefix) {\n    return path;\n  }\n\n  const pathname = pathNoQueryHash(path);\n  return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(`${prefix}${pathname}`) + path.slice(pathname.length);\n}\n\nfunction hasPathPrefix(path, prefix) {\n  path = pathNoQueryHash(path);\n  return path === prefix || path.startsWith(prefix + '/');\n}\n\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    locale = locale || (0, _normalizeLocalePath).normalizeLocalePath(path, locales).detectedLocale;\n    const detectedDomain = detectDomainLocale(domainLocales, undefined, locale);\n\n    if (detectedDomain) {\n      return `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${basePath || ''}${locale === detectedDomain.defaultLocale ? '' : `/${locale}`}${path}`;\n    }\n\n    return false;\n  } else {\n    return false;\n  }\n}\n\nfunction addLocale(path, locale, defaultLocale) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    if (locale && locale !== defaultLocale) {\n      const pathname = pathNoQueryHash(path);\n      const pathLower = pathname.toLowerCase();\n      const localeLower = locale.toLowerCase();\n\n      if (!hasPathPrefix(pathLower, '/' + localeLower) && !hasPathPrefix(pathLower, '/api')) {\n        return addPathPrefix(path, '/' + locale);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction delLocale(path, locale) {\n  if (process.env.__NEXT_I18N_SUPPORT) {\n    const pathname = pathNoQueryHash(path);\n    const pathLower = pathname.toLowerCase();\n    const localeLower = locale && locale.toLowerCase();\n    return locale && (pathLower.startsWith('/' + localeLower + '/') || pathLower === '/' + localeLower) ? (pathname.length === locale.length + 1 ? '/' : '') + path.slice(locale.length + 1) : path;\n  }\n\n  return path;\n}\n\nfunction pathNoQueryHash(path) {\n  const queryIndex = path.indexOf('?');\n  const hashIndex = path.indexOf('#');\n\n  if (queryIndex > -1 || hashIndex > -1) {\n    path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n  }\n\n  return path;\n}\n\nfunction hasBasePath(path) {\n  return hasPathPrefix(path, basePath);\n}\n\nfunction addBasePath(path) {\n  // we only add the basepath on relative urls\n  return addPathPrefix(path, basePath);\n}\n\nfunction delBasePath(path) {\n  path = path.slice(basePath.length);\n  if (!path.startsWith('/')) path = `/${path}`;\n  return path;\n}\n\nfunction isLocalURL(url) {\n  // prevent a hydration mismatch on href for url with anchor refs\n  if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n\n  try {\n    // absolute urls can be local if they are on the same origin\n    const locationOrigin = (0, _utils).getLocationOrigin();\n    const resolved = new URL(url, locationOrigin);\n    return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n  } catch (_) {\n    return false;\n  }\n}\n\nfunction interpolateAs(route, asPathname, query) {\n  let interpolatedRoute = '';\n  const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n  const dynamicGroups = dynamicRegex.groups;\n  const dynamicMatches = // Try to match the dynamic route against the asPath\n  (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n  // TODO: should this take priority; also need to change in the router.\n  query;\n  interpolatedRoute = route;\n  const params = Object.keys(dynamicGroups);\n\n  if (!params.every(param => {\n    let value = dynamicMatches[param] || '';\n    const {\n      repeat,\n      optional\n    } = dynamicGroups[param]; // support single-level catch-all\n    // TODO: more robust handling for user-error (passing `/`)\n\n    let replaced = `[${repeat ? '...' : ''}${param}]`;\n\n    if (optional) {\n      replaced = `${!value ? '/' : ''}[${replaced}]`;\n    }\n\n    if (repeat && !Array.isArray(value)) value = [value];\n    return (optional || param in dynamicMatches) && ( // Interpolate group into data URL if present\n    interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map( // these values should be fully encoded instead of just\n    // path delimiter escaped since they are being inserted\n    // into the URL and we expect URL encoded segments\n    // when parsing dynamic route params\n    segment => encodeURIComponent(segment)).join('/') : encodeURIComponent(value)) || '/');\n  })) {\n    interpolatedRoute = '' // did not satisfy all requirements\n    ; // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n  }\n\n  return {\n    params,\n    result: interpolatedRoute\n  };\n}\n\nfunction omitParmsFromQuery(query, params) {\n  const filteredQuery = {};\n  Object.keys(query).forEach(key => {\n    if (!params.includes(key)) {\n      filteredQuery[key] = query[key];\n    }\n  });\n  return filteredQuery;\n}\n\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  let base;\n  let urlAsString = typeof href === 'string' ? href : (0, _formatUrl).formatWithValidation(href); // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n  const urlParts = urlAsStringNoProto.split('?');\n\n  if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n    console.error(`Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\\\ are not valid in the href`);\n    const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n  } // Return because it cannot be routed by the Next.js router\n\n\n  if (!isLocalURL(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n\n  try {\n    base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL('/', 'http://n');\n  }\n\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n    let interpolatedAs = '';\n\n    if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n\n      if (result) {\n        interpolatedAs = (0, _formatUrl).formatWithValidation({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: omitParmsFromQuery(query, params)\n        });\n      }\n    } // if the origin didn't change, it means we received a relative href\n\n\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_1) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}\n\nfunction stripOrigin(url) {\n  const origin = (0, _utils).getLocationOrigin();\n  return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\n\nfunction prepareUrlAs(router, url, as) {\n  // If url and as provided as an object representation,\n  // we'll format them into the string version here.\n  let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n  const origin = (0, _utils).getLocationOrigin();\n  const hrefHadOrigin = resolvedHref.startsWith(origin);\n  const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n  resolvedHref = stripOrigin(resolvedHref);\n  resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n  const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n  const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n  return {\n    url: preparedUrl,\n    as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n  };\n}\n\nfunction resolveDynamicRoute(pathname, pages) {\n  const cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n\n  if (cleanPathname === '/404' || cleanPathname === '/_error') {\n    return pathname;\n  } // handle resolving href for dynamic routes\n\n\n  if (!pages.includes(cleanPathname)) {\n    // eslint-disable-next-line array-callback-return\n    pages.some(page => {\n      if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n        pathname = page;\n        return true;\n      }\n    });\n  }\n\n  return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\n\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function () {\n  try {\n    let v = '__next'; // eslint-disable-next-line no-sequences\n\n    return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n  } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\n\nfunction fetchRetry(url, attempts, opts) {\n  return fetch(url, {\n    // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n    // Cookies may also be required for `getServerSideProps`.\n    //\n    // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n    // > option.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n    //\n    // > For maximum browser compatibility when it comes to sending &\n    // > receiving cookies, always supply the `credentials: 'same-origin'`\n    // > option instead of relying on the default.\n    // https://github.com/github/fetch#caveats\n    credentials: 'same-origin'\n  }).then(res => {\n    if (!res.ok) {\n      if (attempts > 1 && res.status >= 500) {\n        return fetchRetry(url, attempts - 1, opts);\n      }\n\n      if (res.status === 404) {\n        return res.json().then(data => {\n          if (data.notFound) {\n            return {\n              notFound: SSG_DATA_NOT_FOUND\n            };\n          }\n\n          throw new Error(`Failed to load static props`);\n        });\n      }\n\n      throw new Error(`Failed to load static props`);\n    }\n\n    return opts.text ? res.text() : res.json();\n  });\n}\n\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n  const {\n    href: cacheKey\n  } = new URL(dataHref, window.location.href);\n\n  if (inflightCache[cacheKey] !== undefined) {\n    return inflightCache[cacheKey];\n  }\n\n  return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n    text\n  }).catch(err => {\n    // We should only trigger a server-side transition if this was caused\n    // on a client-side transition. Otherwise, we'd get into an infinite\n    // loop.\n    if (!isServerRender) {\n      (0, _routeLoader).markAssetError(err);\n    }\n\n    throw err;\n  }).then(data => {\n    if (!persistCache || process.env.NODE_ENV !== 'production') {\n      delete inflightCache[cacheKey];\n    }\n\n    return data;\n  }).catch(err => {\n    delete inflightCache[cacheKey];\n    throw err;\n  });\n}\n\nclass Router {\n  constructor(pathname1, query1, as1, {\n    initialProps,\n    pageLoader,\n    App,\n    wrapApp,\n    Component,\n    err,\n    subscription,\n    isFallback,\n    locale,\n    locales,\n    defaultLocale,\n    domainLocales,\n    isPreview,\n    isRsc\n  }) {\n    // Static Data Cache\n    this.sdc = {}; // In-flight Server Data Requests, for deduping\n\n    this.sdr = {}; // In-flight middleware preflight requests\n\n    this.sde = {};\n    this._idx = 0;\n\n    this.onPopState = e => {\n      const state = e.state;\n\n      if (!state) {\n        // We get state as undefined for two reasons.\n        //  1. With older safari (< 8) and older chrome (< 34)\n        //  2. When the URL changed with #\n        //\n        // In the both cases, we don't need to proceed and change the route.\n        // (as it's already changed)\n        // But we can simply replace the state with the new changes.\n        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n        // So, doing the following for (1) does no harm.\n        const {\n          pathname,\n          query\n        } = this;\n        this.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n          pathname: addBasePath(pathname),\n          query\n        }), (0, _utils).getURL());\n        return;\n      }\n\n      if (!state.__N) {\n        return;\n      }\n\n      let forcedScroll;\n      const {\n        url,\n        as,\n        options,\n        idx\n      } = state;\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          if (this._idx !== idx) {\n            // Snapshot current scroll position:\n            try {\n              sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                x: self.pageXOffset,\n                y: self.pageYOffset\n              }));\n            } catch {} // Restore old scroll position:\n\n\n            try {\n              const v = sessionStorage.getItem('__next_scroll_' + idx);\n              forcedScroll = JSON.parse(v);\n            } catch {\n              forcedScroll = {\n                x: 0,\n                y: 0\n              };\n            }\n          }\n        }\n      }\n\n      this._idx = idx;\n      const {\n        pathname\n      } = (0, _parseRelativeUrl).parseRelativeUrl(url); // Make sure we don't re-render on initial load,\n      // can be caused by navigating back from an external site\n\n      if (this.isSsr && as === addBasePath(this.asPath) && pathname === addBasePath(this.pathname)) {\n        return;\n      } // If the downstream application returns falsy, return.\n      // They will then be responsible for handling the event.\n\n\n      if (this._bps && !this._bps(state)) {\n        return;\n      }\n\n      this.change('replaceState', url, as, Object.assign({}, options, {\n        shallow: options.shallow && this._shallow,\n        locale: options.locale || this.defaultLocale\n      }), forcedScroll);\n    }; // represents the current component key\n\n\n    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname1); // set up the component cache (by route keys)\n\n    this.components = {}; // We should not keep the cache, if there's an error\n    // Otherwise, this cause issues when when going back and\n    // come again to the errored page.\n\n    if (pathname1 !== '/_error') {\n      this.components[route] = {\n        Component,\n        initial: true,\n        props: initialProps,\n        err,\n        __N_SSG: initialProps && initialProps.__N_SSG,\n        __N_SSP: initialProps && initialProps.__N_SSP,\n        __N_RSC: !!isRsc\n      };\n    }\n\n    this.components['/_app'] = {\n      Component: App,\n      styleSheets: []\n    }; // Backwards compat for Router.router.events\n    // TODO: Should be remove the following major version as it was never documented\n\n    this.events = Router.events;\n    this.pageLoader = pageLoader; // if auto prerendered and dynamic route wait to update asPath\n    // until after mount to prevent hydration mismatch\n\n    const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n\n    this.basePath = basePath;\n    this.sub = subscription;\n    this.clc = null;\n    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating\n    // back from external site\n\n    this.isSsr = true;\n    this.isLocaleDomain = false;\n    this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      this.locales = locales;\n      this.defaultLocale = defaultLocale;\n      this.domainLocales = domainLocales;\n      this.isLocaleDomain = !!detectDomainLocale(domainLocales, self.location.hostname);\n    }\n\n    this.state = {\n      route,\n      pathname: pathname1,\n      query: query1,\n      asPath: autoExportDynamic ? pathname1 : as1,\n      isPreview: !!isPreview,\n      locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n      isFallback\n    };\n\n    if (typeof window !== 'undefined') {\n      // make sure \"as\" doesn't start with double slashes or else it can\n      // throw an error as it's considered invalid\n      if (!as1.startsWith('//')) {\n        // in order for `e.state` to work on the `onpopstate` event\n        // we have to register the initial route upon initialization\n        const options = {\n          locale\n        };\n        options._shouldResolveHref = as1 !== pathname1;\n        this.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n          pathname: addBasePath(pathname1),\n          query: query1\n        }), (0, _utils).getURL(), options);\n      }\n\n      window.addEventListener('popstate', this.onPopState); // enable custom scroll restoration handling when available\n      // otherwise fallback to browser's default handling\n\n      if (process.env.__NEXT_SCROLL_RESTORATION) {\n        if (manualScrollRestoration) {\n          window.history.scrollRestoration = 'manual';\n        }\n      }\n    }\n  }\n\n  reload() {\n    window.location.reload();\n  }\n  /**\n  * Go back in history\n  */\n\n\n  back() {\n    window.history.back();\n  }\n  /**\n  * Performs a `pushState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  push(url, as, options = {}) {\n    if (process.env.__NEXT_SCROLL_RESTORATION) {\n      // TODO: remove in the future when we update history before route change\n      // is complete, as the popstate event should handle this capture.\n      if (manualScrollRestoration) {\n        try {\n          // Snapshot scroll position right before navigating to a new page:\n          sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n            x: self.pageXOffset,\n            y: self.pageYOffset\n          }));\n        } catch {}\n      }\n    }\n\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('pushState', url, as, options);\n  }\n  /**\n  * Performs a `replaceState` with arguments\n  * @param url of the route\n  * @param as masks `url` for the browser\n  * @param options object you can define `shallow` and other options\n  */\n\n\n  replace(url, as, options = {}) {\n    ({\n      url,\n      as\n    } = prepareUrlAs(this, url, as));\n    return this.change('replaceState', url, as, options);\n  }\n\n  async change(method, url, as, options, forcedScroll) {\n    if (!isLocalURL(url)) {\n      window.location.href = url;\n      return false;\n    }\n\n    const shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n    const nextState = { ...this.state\n    }; // for static pages with query params in the URL we delay\n    // marking the router ready until after the query is updated\n\n    if (options._h) {\n      this.isReady = true;\n    }\n\n    const prevLocale = nextState.locale;\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n\n      if (typeof options.locale === 'undefined') {\n        options.locale = nextState.locale;\n      }\n\n      const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n      const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n\n      if (localePathResult.detectedLocale) {\n        nextState.locale = localePathResult.detectedLocale;\n        parsedAs.pathname = addBasePath(parsedAs.pathname);\n        as = (0, _formatUrl).formatWithValidation(parsedAs);\n        url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n      }\n\n      let didNavigate = false; // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        var ref; // if the locale isn't configured hard navigate to show 404 page\n\n        if (!((ref = this.locales) === null || ref === void 0 ? void 0 : ref.includes(nextState.locale))) {\n          parsedAs.pathname = addLocale(parsedAs.pathname, nextState.locale);\n          window.location.href = (0, _formatUrl).formatWithValidation(parsedAs); // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n\n          didNavigate = true;\n        }\n      }\n\n      const detectedDomain = detectDomainLocale(this.domainLocales, undefined, nextState.locale); // we need to wrap this in the env check again since regenerator runtime\n      // moves this on its own due to the return\n\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        // if we are navigating to a domain locale ensure we redirect to the\n        // correct domain\n        if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n          const asNoBasePath = delBasePath(as);\n          window.location.href = `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${addBasePath(`${nextState.locale === detectedDomain.defaultLocale ? '' : `/${nextState.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`; // this was previously a return but was removed in favor\n          // of better dead code elimination with regenerator runtime\n\n          didNavigate = true;\n        }\n      }\n\n      if (didNavigate) {\n        return new Promise(() => {});\n      }\n    }\n\n    if (!options._h) {\n      this.isSsr = false;\n    } // marking route changes as a navigation start entry\n\n\n    if (_utils.ST) {\n      performance.mark('routeChange');\n    }\n\n    const {\n      shallow = false,\n      scroll = true\n    } = options;\n    const routeProps = {\n      shallow\n    };\n\n    if (this._inFlightRoute) {\n      this.abortComponentLoad(this._inFlightRoute, routeProps);\n    }\n\n    as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n    const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, nextState.locale);\n    this._inFlightRoute = as;\n    let localeChange = prevLocale !== nextState.locale; // If the url change is only related to a hash change\n    // We should not proceed. We should only change the state.\n    // WARNING: `_h` is an internal option for handing Next.js client-side\n    // hydration. Your app should _never_ use this property. It may change at\n    // any time without notice.\n\n    if (!options._h && this.onlyAHashChange(cleanedAs) && !localeChange) {\n      nextState.asPath = cleanedAs;\n      Router.events.emit('hashChangeStart', as, routeProps); // TODO: do we need the resolved href when only a hash change?\n\n      this.changeState(method, url, as, { ...options,\n        scroll: false\n      });\n\n      if (scroll) {\n        this.scrollToHash(cleanedAs);\n      }\n\n      this.set(nextState, this.components[nextState.route], null);\n      Router.events.emit('hashChangeComplete', as, routeProps);\n      return true;\n    }\n\n    let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n    let {\n      pathname,\n      query\n    } = parsed; // The build manifest needs to be loaded before auto-static dynamic pages\n    // get their query parameters to allow ensuring they can be parsed properly\n    // when rewritten to\n\n    let pages, rewrites;\n\n    try {\n      [pages, {\n        __rewrites: rewrites\n      }] = await Promise.all([this.pageLoader.getPageList(), (0, _routeLoader).getClientBuildManifest(), this.pageLoader.getMiddlewareList()]);\n    } catch (err) {\n      // If we fail to resolve the page list or client-build manifest, we must\n      // do a server-side transition:\n      window.location.href = as;\n      return false;\n    } // If asked to change the current URL we should reload the current page\n    // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n    // We also need to set the method = replaceState always\n    // as this should not go into the history (That's how browsers work)\n    // We should compare the new asPath to the current asPath, not the url\n\n\n    if (!this.urlIsNew(cleanedAs) && !localeChange) {\n      method = 'replaceState';\n    } // we need to resolve the as value using rewrites for dynamic SSG\n    // pages to allow building the data URL correctly\n\n\n    let resolvedAs = as; // url and as should always be prefixed with basePath by this\n    // point by either next/link or router.push/replace so strip the\n    // basePath from the pathname to match the pages dir 1-to-1\n\n    pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n\n    if (shouldResolveHref && pathname !== '/_error') {\n      options._shouldResolveHref = true;\n\n      if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n        const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(cleanedAs, nextState.locale)), pages, rewrites, query, p => resolveDynamicRoute(p, pages), this.locales);\n\n        if (rewritesResult.externalDest) {\n          location.href = as;\n          return true;\n        }\n\n        resolvedAs = rewritesResult.asPath;\n\n        if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n          // if this directly matches a page we need to update the href to\n          // allow the correct page chunk to be loaded\n          pathname = rewritesResult.resolvedHref;\n          parsed.pathname = addBasePath(pathname);\n          url = (0, _formatUrl).formatWithValidation(parsed);\n        }\n      } else {\n        parsed.pathname = resolveDynamicRoute(pathname, pages);\n\n        if (parsed.pathname !== pathname) {\n          pathname = parsed.pathname;\n          parsed.pathname = addBasePath(pathname);\n          url = (0, _formatUrl).formatWithValidation(parsed);\n        }\n      }\n    }\n\n    if (!isLocalURL(as)) {\n      if (process.env.NODE_ENV !== 'production') {\n        throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n      }\n\n      window.location.href = as;\n      return false;\n    }\n\n    resolvedAs = delLocale(delBasePath(resolvedAs), nextState.locale);\n    /**\n    * If the route update was triggered for client-side hydration and\n    * the rendered route is not dynamic do not check the preflight\n    * request as it is not necessary.\n    */\n\n    if ((!options.shallow || options._h === 1) && (options._h !== 1 || (0, _isDynamic).isDynamicRoute((0, _normalizeTrailingSlash).removePathTrailingSlash(pathname)))) {\n      const effect = await this._preflightRequest({\n        as,\n        cache: process.env.NODE_ENV === 'production',\n        pages,\n        pathname,\n        query,\n        locale: nextState.locale,\n        isPreview: nextState.isPreview\n      });\n\n      if (effect.type === 'rewrite') {\n        query = { ...query,\n          ...effect.parsedAs.query\n        };\n        resolvedAs = effect.asPath;\n        pathname = effect.resolvedHref;\n        parsed.pathname = effect.resolvedHref;\n        url = (0, _formatUrl).formatWithValidation(parsed);\n      } else if (effect.type === 'redirect' && effect.newAs) {\n        return this.change(method, effect.newUrl, effect.newAs, options);\n      } else if (effect.type === 'redirect' && effect.destination) {\n        window.location.href = effect.destination;\n        return new Promise(() => {});\n      } else if (effect.type === 'refresh' && as !== window.location.pathname) {\n        window.location.href = as;\n        return new Promise(() => {});\n      }\n    }\n\n    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n\n    if ((0, _isDynamic).isDynamicRoute(route)) {\n      const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n      const asPathname = parsedAs.pathname;\n      const routeRegex = (0, _routeRegex).getRouteRegex(route);\n      const routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n      const shouldInterpolate = route === asPathname;\n      const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n\n      if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n        const missingParams = Object.keys(routeRegex.groups).filter(param => !query[param]);\n\n        if (missingParams.length > 0) {\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n          }\n\n          throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n        }\n      } else if (shouldInterpolate) {\n        as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs, {\n          pathname: interpolatedAs.result,\n          query: omitParmsFromQuery(query, interpolatedAs.params)\n        }));\n      } else {\n        // Merge params into `query`, overwriting any specified in search\n        Object.assign(query, routeMatch);\n      }\n    }\n\n    Router.events.emit('routeChangeStart', as, routeProps);\n\n    try {\n      var ref1, ref2;\n      let routeInfo = await this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, nextState.locale, nextState.isPreview);\n      let {\n        error,\n        props,\n        __N_SSG,\n        __N_SSP\n      } = routeInfo;\n      const component = routeInfo.Component;\n\n      if (component && component.unstable_scriptLoader) {\n        const scripts = [].concat(component.unstable_scriptLoader());\n        scripts.forEach(script => {\n          (0, _script).handleClientScriptLoad(script.props);\n        });\n      } // handle redirect on client-transition\n\n\n      if ((__N_SSG || __N_SSP) && props) {\n        if (props.pageProps && props.pageProps.__N_REDIRECT) {\n          const destination = props.pageProps.__N_REDIRECT; // check if destination is internal (resolves to a page) and attempt\n          // client-navigation if it is falling back to hard navigation if\n          // it's not\n\n          if (destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n            const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n            parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n            const {\n              url: newUrl,\n              as: newAs\n            } = prepareUrlAs(this, destination, destination);\n            return this.change(method, newUrl, newAs, options);\n          }\n\n          window.location.href = destination;\n          return new Promise(() => {});\n        }\n\n        nextState.isPreview = !!props.__N_PREVIEW; // handle SSG data 404\n\n        if (props.notFound === SSG_DATA_NOT_FOUND) {\n          let notFoundRoute;\n\n          try {\n            await this.fetchComponent('/404');\n            notFoundRoute = '/404';\n          } catch (_) {\n            notFoundRoute = '/_error';\n          }\n\n          routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n            shallow: false\n          }, nextState.locale, nextState.isPreview);\n        }\n      }\n\n      Router.events.emit('beforeHistoryChange', as, routeProps);\n      this.changeState(method, url, as, options);\n\n      if (options._h && pathname === '/_error' && ((ref1 = self.__NEXT_DATA__.props) === null || ref1 === void 0 ? void 0 : (ref2 = ref1.pageProps) === null || ref2 === void 0 ? void 0 : ref2.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n        // ensure statusCode is still correct for static 500 page\n        // when updating query information\n        props.pageProps.statusCode = 500;\n      } // shallow routing is only allowed for same page URL changes.\n\n\n      const isValidShallowRoute = options.shallow && nextState.route === route;\n\n      var _scroll;\n\n      const shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n      const resetScroll = shouldScroll ? {\n        x: 0,\n        y: 0\n      } : null;\n      await this.set({ ...nextState,\n        route,\n        pathname,\n        query,\n        asPath: cleanedAs,\n        isFallback: false\n      }, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch(e => {\n        if (e.cancelled) error = error || e;else throw e;\n      });\n\n      if (error) {\n        Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n        throw error;\n      }\n\n      if (process.env.__NEXT_I18N_SUPPORT) {\n        if (nextState.locale) {\n          document.documentElement.lang = nextState.locale;\n        }\n      }\n\n      Router.events.emit('routeChangeComplete', as, routeProps);\n      return true;\n    } catch (err1) {\n      if ((0, _isError).default(err1) && err1.cancelled) {\n        return false;\n      }\n\n      throw err1;\n    }\n  }\n\n  changeState(method, url, as, options = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof window.history === 'undefined') {\n        console.error(`Warning: window.history is not available.`);\n        return;\n      }\n\n      if (typeof window.history[method] === 'undefined') {\n        console.error(`Warning: window.history.${method} is not available`);\n        return;\n      }\n    }\n\n    if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n      this._shallow = options.shallow;\n      window.history[method]({\n        url,\n        as,\n        options,\n        __N: true,\n        idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n      }, // Most browsers currently ignores this parameter, although they may use it in the future.\n      // Passing the empty string here should be safe against future changes to the method.\n      // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n      '', as);\n    }\n  }\n\n  async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n    if (err.cancelled) {\n      // bubble up cancellation errors\n      throw err;\n    }\n\n    if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n      Router.events.emit('routeChangeError', err, as, routeProps); // If we can't load the page it could be one of following reasons\n      //  1. Page doesn't exists\n      //  2. Page does exist in a different zone\n      //  3. Internal error while loading the page\n      // So, doing a hard reload is the proper way to deal with this.\n\n      window.location.href = as; // Changing the URL doesn't block executing the current code path.\n      // So let's throw a cancellation error stop the routing logic.\n\n      throw buildCancellationError();\n    }\n\n    try {\n      let Component;\n      let styleSheets;\n      let props;\n\n      if (typeof Component === 'undefined' || typeof styleSheets === 'undefined') {\n        ({\n          page: Component,\n          styleSheets\n        } = await this.fetchComponent('/_error'));\n      }\n\n      const routeInfo = {\n        props,\n        Component,\n        styleSheets,\n        err,\n        error: err\n      };\n\n      if (!routeInfo.props) {\n        try {\n          routeInfo.props = await this.getInitialProps(Component, {\n            err,\n            pathname,\n            query\n          });\n        } catch (gipErr) {\n          console.error('Error in error page `getInitialProps`: ', gipErr);\n          routeInfo.props = {};\n        }\n      }\n\n      return routeInfo;\n    } catch (routeInfoErr) {\n      return this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n    }\n  }\n\n  async getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, locale, isPreview) {\n    try {\n      const existingRouteInfo = this.components[route];\n\n      if (routeProps.shallow && existingRouteInfo && this.route === route) {\n        return existingRouteInfo;\n      }\n\n      let cachedRouteInfo = undefined; // can only use non-initial route info\n      // cannot reuse route info in development since it can change after HMR\n\n      if (process.env.NODE_ENV !== 'development' && existingRouteInfo && !('initial' in existingRouteInfo)) {\n        cachedRouteInfo = existingRouteInfo;\n      }\n\n      const routeInfo = cachedRouteInfo || (await this.fetchComponent(route).then(res => ({\n        Component: res.page,\n        styleSheets: res.styleSheets,\n        __N_SSG: res.mod.__N_SSG,\n        __N_SSP: res.mod.__N_SSP,\n        __N_RSC: !!res.mod.__next_rsc__\n      })));\n      const {\n        Component,\n        __N_SSG,\n        __N_SSP,\n        __N_RSC\n      } = routeInfo;\n\n      if (process.env.NODE_ENV !== 'production') {\n        const {\n          isValidElementType\n        } = require('next/dist/compiled/react-is');\n\n        if (!isValidElementType(Component)) {\n          throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n        }\n      }\n\n      let dataHref; // For server components, non-SSR pages will have statically optimized\n      // flight data in a production build.\n      // So only development and SSR pages will always have the real-time\n      // generated and streamed flight data.\n\n      const useStreamedFlightData = (process.env.NODE_ENV !== 'production' || __N_SSP) && __N_RSC;\n\n      if (__N_SSG || __N_SSP || __N_RSC) {\n        dataHref = this.pageLoader.getDataHref({\n          href: (0, _formatUrl).formatWithValidation({\n            pathname,\n            query\n          }),\n          asPath: resolvedAs,\n          ssg: __N_SSG,\n          flight: useStreamedFlightData,\n          locale\n        });\n      }\n\n      const props = await this._getData(() => (__N_SSG || __N_SSP || __N_RSC) && !useStreamedFlightData ? fetchNextData(dataHref, this.isSsr, false, __N_SSG ? this.sdc : this.sdr, !!__N_SSG && !isPreview) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`\n      {\n        pathname,\n        query,\n        asPath: as,\n        locale,\n        locales: this.locales,\n        defaultLocale: this.defaultLocale\n      }));\n\n      if (__N_RSC) {\n        if (useStreamedFlightData) {\n          const {\n            data\n          } = await this._getData(() => this._getFlightData(dataHref));\n          props.pageProps = Object.assign(props.pageProps, {\n            __flight__: data\n          });\n        } else {\n          const {\n            __flight__\n          } = props;\n          props.pageProps = Object.assign({}, props.pageProps, {\n            __flight__\n          });\n        }\n      }\n\n      routeInfo.props = props;\n      this.components[route] = routeInfo;\n      return routeInfo;\n    } catch (err) {\n      return this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);\n    }\n  }\n\n  set(state, data, resetScroll) {\n    this.state = state;\n    return this.sub(data, this.components['/_app'].Component, resetScroll);\n  }\n  /**\n  * Callback to execute before replacing router state\n  * @param cb callback to be executed\n  */\n\n\n  beforePopState(cb) {\n    this._bps = cb;\n  }\n\n  onlyAHashChange(as) {\n    if (!this.asPath) return false;\n    const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n    const [newUrlNoHash, newHash] = as.split('#'); // Makes sure we scroll to the provided hash if the url/hash are the same\n\n    if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n      return true;\n    } // If the urls are change, there's more than a hash change\n\n\n    if (oldUrlNoHash !== newUrlNoHash) {\n      return false;\n    } // If the hash has changed, then it's a hash only change.\n    // This check is necessary to handle both the enter and\n    // leave hash === '' cases. The identity case falls through\n    // and is treated as a next reload.\n\n\n    return oldHash !== newHash;\n  }\n\n  scrollToHash(as) {\n    const [, hash = ''] = as.split('#'); // Scroll to top if the hash is just `#` with no value or `#top`\n    // To mirror browsers\n\n    if (hash === '' || hash === 'top') {\n      window.scrollTo(0, 0);\n      return;\n    } // First we check if the element by id is found\n\n\n    const idEl = document.getElementById(hash);\n\n    if (idEl) {\n      idEl.scrollIntoView();\n      return;\n    } // If there's no element with the id, we check the `name` property\n    // To mirror browsers\n\n\n    const nameEl = document.getElementsByName(hash)[0];\n\n    if (nameEl) {\n      nameEl.scrollIntoView();\n    }\n  }\n\n  urlIsNew(asPath) {\n    return this.asPath !== asPath;\n  }\n  /**\n  * Prefetch page code, you may wait for the data during page rendering.\n  * This feature only works in production!\n  * @param url the href of prefetched page\n  * @param asPath the as path of the prefetched page\n  */\n\n\n  async prefetch(url, asPath = url, options = {}) {\n    let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n    let {\n      pathname,\n      query\n    } = parsed;\n\n    if (process.env.__NEXT_I18N_SUPPORT) {\n      if (options.locale === false) {\n        pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, this.locales).pathname;\n        parsed.pathname = pathname;\n        url = (0, _formatUrl).formatWithValidation(parsed);\n        let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n        const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n        parsedAs.pathname = localePathResult.pathname;\n        options.locale = localePathResult.detectedLocale || this.defaultLocale;\n        asPath = (0, _formatUrl).formatWithValidation(parsedAs);\n      }\n    }\n\n    const pages = await this.pageLoader.getPageList();\n    let resolvedAs = asPath;\n\n    if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n      let rewrites;\n      ({\n        __rewrites: rewrites\n      } = await (0, _routeLoader).getClientBuildManifest());\n      const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, p => resolveDynamicRoute(p, pages), this.locales);\n\n      if (rewritesResult.externalDest) {\n        return;\n      }\n\n      resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n\n      if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n        // if this directly matches a page we need to update the href to\n        // allow the correct page chunk to be loaded\n        pathname = rewritesResult.resolvedHref;\n        parsed.pathname = pathname;\n        url = (0, _formatUrl).formatWithValidation(parsed);\n      }\n    } else {\n      parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n\n      if (parsed.pathname !== pathname) {\n        pathname = parsed.pathname;\n        parsed.pathname = pathname;\n        url = (0, _formatUrl).formatWithValidation(parsed);\n      }\n    } // Prefetch is not supported in development mode because it would trigger on-demand-entries\n\n\n    if (process.env.NODE_ENV !== 'production') {\n      return;\n    }\n\n    const effects = await this._preflightRequest({\n      as: addBasePath(asPath),\n      cache: true,\n      pages,\n      pathname,\n      query,\n      locale: this.locale,\n      isPreview: this.isPreview\n    });\n\n    if (effects.type === 'rewrite') {\n      parsed.pathname = effects.resolvedHref;\n      pathname = effects.resolvedHref;\n      query = { ...query,\n        ...effects.parsedAs.query\n      };\n      resolvedAs = effects.asPath;\n      url = (0, _formatUrl).formatWithValidation(parsed);\n    }\n\n    const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n    await Promise.all([this.pageLoader._isSsg(route).then(isSsg => {\n      return isSsg ? fetchNextData(this.pageLoader.getDataHref({\n        href: url,\n        asPath: resolvedAs,\n        ssg: true,\n        locale: typeof options.locale !== 'undefined' ? options.locale : this.locale\n      }), false, false, this.sdc, true) : false;\n    }), this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]);\n  }\n\n  async fetchComponent(route) {\n    let cancelled = false;\n\n    const cancel = this.clc = () => {\n      cancelled = true;\n    };\n\n    const handleCancelled = () => {\n      if (cancelled) {\n        const error = new Error(`Abort fetching component for route: \"${route}\"`);\n        error.cancelled = true;\n        throw error;\n      }\n\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n    };\n\n    try {\n      const componentResult = await this.pageLoader.loadPage(route);\n      handleCancelled();\n      return componentResult;\n    } catch (err) {\n      handleCancelled();\n      throw err;\n    }\n  }\n\n  _getData(fn) {\n    let cancelled = false;\n\n    const cancel = () => {\n      cancelled = true;\n    };\n\n    this.clc = cancel;\n    return fn().then(data => {\n      if (cancel === this.clc) {\n        this.clc = null;\n      }\n\n      if (cancelled) {\n        const err = new Error('Loading initial props cancelled');\n        err.cancelled = true;\n        throw err;\n      }\n\n      return data;\n    });\n  }\n\n  _getFlightData(dataHref) {\n    // Do not cache RSC flight response since it's not a static resource\n    return fetchNextData(dataHref, true, true, this.sdc, false).then(serialized => {\n      return {\n        data: serialized\n      };\n    });\n  }\n\n  async _preflightRequest(options) {\n    const asPathname = pathNoQueryHash(options.as);\n    const cleanedAs = delLocale(hasBasePath(asPathname) ? delBasePath(asPathname) : asPathname, options.locale);\n    const fns = await this.pageLoader.getMiddlewareList();\n    const requiresPreflight = fns.some(([middleware, isSSR]) => {\n      return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n    });\n\n    if (!requiresPreflight) {\n      return {\n        type: 'next'\n      };\n    }\n\n    const preflightHref = addLocale(options.as, options.locale);\n    let preflight;\n\n    try {\n      preflight = await this._getPreflightData({\n        preflightHref,\n        shouldCache: options.cache,\n        isPreview: options.isPreview\n      });\n    } catch (err) {\n      // If preflight request fails, we need to do a hard-navigation.\n      return {\n        type: 'redirect',\n        destination: options.as\n      };\n    }\n\n    if (preflight.rewrite) {\n      // for external rewrites we need to do a hard navigation\n      // to the resource\n      if (!preflight.rewrite.startsWith('/')) {\n        return {\n          type: 'redirect',\n          destination: options.as\n        };\n      }\n\n      const parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n      const fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n      let matchedPage;\n      let resolvedHref;\n\n      if (options.pages.includes(fsPathname)) {\n        matchedPage = true;\n        resolvedHref = fsPathname;\n      } else {\n        resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n\n        if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n          matchedPage = true;\n        }\n      }\n\n      return {\n        type: 'rewrite',\n        asPath: parsed.pathname,\n        parsedAs: parsed,\n        matchedPage,\n        resolvedHref\n      };\n    }\n\n    if (preflight.redirect) {\n      if (preflight.redirect.startsWith('/')) {\n        const cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n        const {\n          url: newUrl,\n          as: newAs\n        } = prepareUrlAs(this, cleanRedirect, cleanRedirect);\n        return {\n          type: 'redirect',\n          newUrl,\n          newAs\n        };\n      }\n\n      return {\n        type: 'redirect',\n        destination: preflight.redirect\n      };\n    } // For SSR requests, they will be handled like normal pages.\n\n\n    if (preflight.refresh && !preflight.ssr) {\n      return {\n        type: 'refresh'\n      };\n    }\n\n    return {\n      type: 'next'\n    };\n  }\n\n  _getPreflightData(params) {\n    const {\n      preflightHref,\n      shouldCache = false,\n      isPreview\n    } = params;\n    const {\n      href: cacheKey\n    } = new URL(preflightHref, window.location.href);\n\n    if (process.env.NODE_ENV === 'production' && !isPreview && shouldCache && this.sde[cacheKey]) {\n      return Promise.resolve(this.sde[cacheKey]);\n    }\n\n    return fetch(preflightHref, {\n      method: 'HEAD',\n      credentials: 'same-origin',\n      headers: {\n        'x-middleware-preflight': '1'\n      }\n    }).then(res => {\n      if (!res.ok) {\n        throw new Error(`Failed to preflight request`);\n      }\n\n      return {\n        cache: res.headers.get('x-middleware-cache'),\n        redirect: res.headers.get('Location'),\n        refresh: res.headers.has('x-middleware-refresh'),\n        rewrite: res.headers.get('x-middleware-rewrite'),\n        ssr: !!res.headers.get('x-middleware-ssr')\n      };\n    }).then(data => {\n      if (shouldCache && data.cache !== 'no-cache') {\n        this.sde[cacheKey] = data;\n      }\n\n      return data;\n    }).catch(err => {\n      delete this.sde[cacheKey];\n      throw err;\n    });\n  }\n\n  getInitialProps(Component, ctx) {\n    const {\n      Component: App\n    } = this.components['/_app'];\n\n    const AppTree = this._wrapApp(App);\n\n    ctx.AppTree = AppTree;\n    return (0, _utils).loadGetInitialProps(App, {\n      AppTree,\n      Component,\n      router: this,\n      ctx\n    });\n  }\n\n  abortComponentLoad(as, routeProps) {\n    if (this.clc) {\n      Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n      this.clc();\n      this.clc = null;\n    }\n  }\n\n  get route() {\n    return this.state.route;\n  }\n\n  get pathname() {\n    return this.state.pathname;\n  }\n\n  get query() {\n    return this.state.query;\n  }\n\n  get asPath() {\n    return this.state.asPath;\n  }\n\n  get locale() {\n    return this.state.locale;\n  }\n\n  get isFallback() {\n    return this.state.isFallback;\n  }\n\n  get isPreview() {\n    return this.state.isPreview;\n  }\n\n}\n\nexports.default = Router;\nRouter.events = (0, _mitt).default();","map":{"version":3,"sources":["../../../../shared/lib/router/router.ts"],"names":["detectDomainLocale","process","env","__NEXT_I18N_SUPPORT","require","basePath","__NEXT_ROUTER_BASEPATH","buildCancellationError","Object","assign","Error","cancelled","addPathPrefix","path","prefix","startsWith","pathname","pathNoQueryHash","normalizePathTrailingSlash","slice","length","hasPathPrefix","getDomainLocale","locale","locales","domainLocales","normalizeLocalePath","detectedLocale","detectedDomain","undefined","http","domain","defaultLocale","addLocale","pathLower","toLowerCase","localeLower","delLocale","queryIndex","indexOf","hashIndex","substring","hasBasePath","addBasePath","delBasePath","isLocalURL","url","locationOrigin","getLocationOrigin","resolved","URL","origin","_","interpolateAs","route","asPathname","query","interpolatedRoute","dynamicRegex","getRouteRegex","dynamicGroups","groups","dynamicMatches","getRouteMatcher","params","keys","every","param","value","repeat","optional","replaced","Array","isArray","replace","map","segment","encodeURIComponent","join","result","omitParmsFromQuery","filteredQuery","forEach","key","includes","resolveHref","router","href","resolveAs","base","urlAsString","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","urlParts","split","console","error","normalizedUrl","normalizeRepeatedSlashes","asPath","finalUrl","interpolatedAs","isDynamicRoute","searchParams","searchParamsToUrlQuery","hash","resolvedHref","stripOrigin","prepareUrlAs","as","resolvedAs","hrefHadOrigin","asHadOrigin","preparedUrl","preparedAs","resolveDynamicRoute","pages","cleanPathname","removePathTrailingSlash","denormalizePagePath","some","page","re","test","manualScrollRestoration","__NEXT_SCROLL_RESTORATION","window","history","v","sessionStorage","setItem","removeItem","n","SSG_DATA_NOT_FOUND","Symbol","fetchRetry","attempts","opts","fetch","credentials","then","res","ok","status","json","data","notFound","text","fetchNextData","dataHref","isServerRender","inflightCache","persistCache","cacheKey","location","catch","err","markAssetError","NODE_ENV","Router","sdc","sdr","sde","_idx","events","mitt","initialProps","pageLoader","App","wrapApp","Component","subscription","isFallback","isPreview","isRsc","components","initial","props","__N_SSG","__N_SSP","__N_RSC","styleSheets","autoExportDynamic","self","__NEXT_DATA__","autoExport","sub","clc","_wrapApp","isSsr","isLocaleDomain","isReady","gssp","gip","appGip","gsp","search","__NEXT_HAS_REWRITES","hostname","state","options","_shouldResolveHref","changeState","getURL","addEventListener","onPopState","scrollRestoration","e","__N","forcedScroll","idx","JSON","stringify","x","pageXOffset","y","pageYOffset","getItem","parse","parseRelativeUrl","_bps","change","shallow","_shallow","reload","back","push","method","shouldResolveHref","_h","nextState","prevLocale","parsedAs","localePathResult","didNavigate","asNoBasePath","Promise","ST","performance","mark","scroll","routeProps","_inFlightRoute","abortComponentLoad","cleanedAs","localeChange","onlyAHashChange","emit","scrollToHash","set","parsed","rewrites","__rewrites","all","getPageList","getClientBuildManifest","getMiddlewareList","urlIsNew","rewritesResult","resolveRewrites","p","externalDest","matchedPage","effect","_preflightRequest","cache","type","newAs","newUrl","destination","routeRegex","routeMatch","shouldInterpolate","missingParams","filter","warn","routeInfo","getRouteInfo","component","unstable_scriptLoader","scripts","concat","script","handleClientScriptLoad","pageProps","__N_REDIRECT","__N_REDIRECT_BASE_PATH","parsedHref","__N_PREVIEW","notFoundRoute","fetchComponent","statusCode","isValidShallowRoute","shouldScroll","resetScroll","document","documentElement","lang","isError","handleRouteInfoError","loadErrorFail","isAssetError","getInitialProps","gipErr","routeInfoErr","existingRouteInfo","cachedRouteInfo","mod","__next_rsc__","isValidElementType","useStreamedFlightData","getDataHref","ssg","flight","_getData","_getFlightData","__flight__","getProperError","beforePopState","cb","oldUrlNoHash","oldHash","newUrlNoHash","newHash","scrollTo","idEl","getElementById","scrollIntoView","nameEl","getElementsByName","prefetch","effects","_isSsg","isSsg","priority","cancel","handleCancelled","componentResult","loadPage","fn","serialized","fns","requiresPreflight","middleware","isSSR","getMiddlewareRegex","preflightHref","preflight","_getPreflightData","shouldCache","rewrite","fsPathname","redirect","cleanRedirect","refresh","ssr","resolve","headers","get","has","ctx","AppTree","loadGetInitialProps"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getDomainLocale = getDomainLocale;\nexports.addLocale = addLocale;\nexports.delLocale = delLocale;\nexports.hasBasePath = hasBasePath;\nexports.addBasePath = addBasePath;\nexports.delBasePath = delBasePath;\nexports.isLocalURL = isLocalURL;\nexports.interpolateAs = interpolateAs;\nexports.resolveHref = resolveHref;\nexports.default = void 0;\nvar _normalizeTrailingSlash = require(\"../../../client/normalize-trailing-slash\");\nvar _routeLoader = require(\"../../../client/route-loader\");\nvar _script = require(\"../../../client/script\");\nvar _isError = _interopRequireWildcard(require(\"../../../lib/is-error\"));\nvar _denormalizePagePath = require(\"../page-path/denormalize-page-path\");\nvar _normalizeLocalePath = require(\"../i18n/normalize-locale-path\");\nvar _mitt = _interopRequireDefault(require(\"../mitt\"));\nvar _utils = require(\"../utils\");\nvar _isDynamic = require(\"./utils/is-dynamic\");\nvar _parseRelativeUrl = require(\"./utils/parse-relative-url\");\nvar _querystring = require(\"./utils/querystring\");\nvar _resolveRewrites = _interopRequireDefault(require(\"./utils/resolve-rewrites\"));\nvar _routeMatcher = require(\"./utils/route-matcher\");\nvar _routeRegex = require(\"./utils/route-regex\");\nvar _getMiddlewareRegex = require(\"./utils/get-middleware-regex\");\nvar _formatUrl = require(\"./utils/format-url\");\nfunction _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n        default: obj\n    };\n}\nfunction _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n        return obj;\n    } else {\n        var newObj = {};\n        if (obj != null) {\n            for(var key in obj){\n                if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                    var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n                    if (desc.get || desc.set) {\n                        Object.defineProperty(newObj, key, desc);\n                    } else {\n                        newObj[key] = obj[key];\n                    }\n                }\n            }\n        }\n        newObj.default = obj;\n        return newObj;\n    }\n}\nlet detectDomainLocale;\nif (process.env.__NEXT_I18N_SUPPORT) {\n    detectDomainLocale = require('../i18n/detect-domain-locale').detectDomainLocale;\n}\nconst basePath = process.env.__NEXT_ROUTER_BASEPATH || '';\nfunction buildCancellationError() {\n    return Object.assign(new Error('Route Cancelled'), {\n        cancelled: true\n    });\n}\nfunction addPathPrefix(path, prefix) {\n    if (!path.startsWith('/') || !prefix) {\n        return path;\n    }\n    const pathname = pathNoQueryHash(path);\n    return (0, _normalizeTrailingSlash).normalizePathTrailingSlash(`${prefix}${pathname}`) + path.slice(pathname.length);\n}\nfunction hasPathPrefix(path, prefix) {\n    path = pathNoQueryHash(path);\n    return path === prefix || path.startsWith(prefix + '/');\n}\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        locale = locale || (0, _normalizeLocalePath).normalizeLocalePath(path, locales).detectedLocale;\n        const detectedDomain = detectDomainLocale(domainLocales, undefined, locale);\n        if (detectedDomain) {\n            return `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${basePath || ''}${locale === detectedDomain.defaultLocale ? '' : `/${locale}`}${path}`;\n        }\n        return false;\n    } else {\n        return false;\n    }\n}\nfunction addLocale(path, locale, defaultLocale) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        if (locale && locale !== defaultLocale) {\n            const pathname = pathNoQueryHash(path);\n            const pathLower = pathname.toLowerCase();\n            const localeLower = locale.toLowerCase();\n            if (!hasPathPrefix(pathLower, '/' + localeLower) && !hasPathPrefix(pathLower, '/api')) {\n                return addPathPrefix(path, '/' + locale);\n            }\n        }\n    }\n    return path;\n}\nfunction delLocale(path, locale) {\n    if (process.env.__NEXT_I18N_SUPPORT) {\n        const pathname = pathNoQueryHash(path);\n        const pathLower = pathname.toLowerCase();\n        const localeLower = locale && locale.toLowerCase();\n        return locale && (pathLower.startsWith('/' + localeLower + '/') || pathLower === '/' + localeLower) ? (pathname.length === locale.length + 1 ? '/' : '') + path.slice(locale.length + 1) : path;\n    }\n    return path;\n}\nfunction pathNoQueryHash(path) {\n    const queryIndex = path.indexOf('?');\n    const hashIndex = path.indexOf('#');\n    if (queryIndex > -1 || hashIndex > -1) {\n        path = path.substring(0, queryIndex > -1 ? queryIndex : hashIndex);\n    }\n    return path;\n}\nfunction hasBasePath(path) {\n    return hasPathPrefix(path, basePath);\n}\nfunction addBasePath(path) {\n    // we only add the basepath on relative urls\n    return addPathPrefix(path, basePath);\n}\nfunction delBasePath(path) {\n    path = path.slice(basePath.length);\n    if (!path.startsWith('/')) path = `/${path}`;\n    return path;\n}\nfunction isLocalURL(url) {\n    // prevent a hydration mismatch on href for url with anchor refs\n    if (url.startsWith('/') || url.startsWith('#') || url.startsWith('?')) return true;\n    try {\n        // absolute urls can be local if they are on the same origin\n        const locationOrigin = (0, _utils).getLocationOrigin();\n        const resolved = new URL(url, locationOrigin);\n        return resolved.origin === locationOrigin && hasBasePath(resolved.pathname);\n    } catch (_) {\n        return false;\n    }\n}\nfunction interpolateAs(route, asPathname, query) {\n    let interpolatedRoute = '';\n    const dynamicRegex = (0, _routeRegex).getRouteRegex(route);\n    const dynamicGroups = dynamicRegex.groups;\n    const dynamicMatches = // Try to match the dynamic route against the asPath\n    (asPathname !== route ? (0, _routeMatcher).getRouteMatcher(dynamicRegex)(asPathname) : '') || // Fall back to reading the values from the href\n    // TODO: should this take priority; also need to change in the router.\n    query;\n    interpolatedRoute = route;\n    const params = Object.keys(dynamicGroups);\n    if (!params.every((param)=>{\n        let value = dynamicMatches[param] || '';\n        const { repeat , optional  } = dynamicGroups[param];\n        // support single-level catch-all\n        // TODO: more robust handling for user-error (passing `/`)\n        let replaced = `[${repeat ? '...' : ''}${param}]`;\n        if (optional) {\n            replaced = `${!value ? '/' : ''}[${replaced}]`;\n        }\n        if (repeat && !Array.isArray(value)) value = [\n            value\n        ];\n        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present\n        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(// these values should be fully encoded instead of just\n        // path delimiter escaped since they are being inserted\n        // into the URL and we expect URL encoded segments\n        // when parsing dynamic route params\n        (segment)=>encodeURIComponent(segment)\n        ).join('/') : encodeURIComponent(value)) || '/');\n    })) {\n        interpolatedRoute = '' // did not satisfy all requirements\n        ;\n    // n.b. We ignore this error because we handle warning for this case in\n    // development in the `<Link>` component directly.\n    }\n    return {\n        params,\n        result: interpolatedRoute\n    };\n}\nfunction omitParmsFromQuery(query, params) {\n    const filteredQuery = {};\n    Object.keys(query).forEach((key)=>{\n        if (!params.includes(key)) {\n            filteredQuery[key] = query[key];\n        }\n    });\n    return filteredQuery;\n}\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === 'string' ? href : (0, _formatUrl).formatWithValidation(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split('?');\n    if ((urlParts[0] || '').match(/(\\/\\/|\\\\)/)) {\n        console.error(`Invalid href passed to next/router: ${urlAsString}, repeated forward-slashes (//) or backslashes \\\\ are not valid in the href`);\n        const normalizedUrl = (0, _utils).normalizeRepeatedSlashes(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : '') + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!isLocalURL(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith('#') ? router.asPath : router.pathname, 'http://n');\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL('/', 'http://n');\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizeTrailingSlash).normalizePathTrailingSlash(finalUrl.pathname);\n        let interpolatedAs = '';\n        if ((0, _isDynamic).isDynamicRoute(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring).searchParamsToUrlQuery(finalUrl.searchParams);\n            const { result , params  } = interpolateAs(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formatUrl).formatWithValidation({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: omitParmsFromQuery(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_1) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = resolveHref(router, url, true);\n    const origin = (0, _utils).getLocationOrigin();\n    const hrefHadOrigin = resolvedHref.startsWith(origin);\n    const asHadOrigin = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefHadOrigin ? resolvedHref : addBasePath(resolvedHref);\n    const preparedAs = as ? stripOrigin(resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asHadOrigin ? preparedAs : addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n}\nconst manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== 'undefined' && 'scrollRestoration' in window.history && !!function() {\n    try {\n        let v = '__next';\n        // eslint-disable-next-line no-sequences\n        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;\n    } catch (n) {}\n}();\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, opts) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin'\n    }).then((res)=>{\n        if (!res.ok) {\n            if (attempts > 1 && res.status >= 500) {\n                return fetchRetry(url, attempts - 1, opts);\n            }\n            if (res.status === 404) {\n                return res.json().then((data)=>{\n                    if (data.notFound) {\n                        return {\n                            notFound: SSG_DATA_NOT_FOUND\n                        };\n                    }\n                    throw new Error(`Failed to load static props`);\n                });\n            }\n            throw new Error(`Failed to load static props`);\n        }\n        return opts.text ? res.text() : res.json();\n    });\n}\nfunction fetchNextData(dataHref, isServerRender, text, inflightCache, persistCache) {\n    const { href: cacheKey  } = new URL(dataHref, window.location.href);\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = fetchRetry(dataHref, isServerRender ? 3 : 1, {\n        text\n    }).catch((err)=>{\n        // We should only trigger a server-side transition if this was caused\n        // on a client-side transition. Otherwise, we'd get into an infinite\n        // loop.\n        if (!isServerRender) {\n            (0, _routeLoader).markAssetError(err);\n        }\n        throw err;\n    }).then((data)=>{\n        if (!persistCache || process.env.NODE_ENV !== 'production') {\n            delete inflightCache[cacheKey];\n        }\n        return data;\n    }).catch((err)=>{\n        delete inflightCache[cacheKey];\n        throw err;\n    });\n}\nclass Router {\n    constructor(pathname1, query1, as1, { initialProps , pageLoader , App , wrapApp , Component , err , subscription , isFallback , locale , locales , defaultLocale , domainLocales , isPreview , isRsc  }){\n        // Static Data Cache\n        this.sdc = {};\n        // In-flight Server Data Requests, for deduping\n        this.sdr = {};\n        // In-flight middleware preflight requests\n        this.sde = {};\n        this._idx = 0;\n        this.onPopState = (e)=>{\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname , query  } = this;\n                this.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n                    pathname: addBasePath(pathname),\n                    query\n                }), (0, _utils).getURL());\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            let forcedScroll;\n            const { url , as , options , idx  } = state;\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    if (this._idx !== idx) {\n                        // Snapshot current scroll position:\n                        try {\n                            sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                                x: self.pageXOffset,\n                                y: self.pageYOffset\n                            }));\n                        } catch  {}\n                        // Restore old scroll position:\n                        try {\n                            const v = sessionStorage.getItem('__next_scroll_' + idx);\n                            forcedScroll = JSON.parse(v);\n                        } catch  {\n                            forcedScroll = {\n                                x: 0,\n                                y: 0\n                            };\n                        }\n                    }\n                }\n            }\n            this._idx = idx;\n            const { pathname  } = (0, _parseRelativeUrl).parseRelativeUrl(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === addBasePath(this.asPath) && pathname === addBasePath(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname1);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname1 !== '/_error') {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP,\n                __N_RSC: !!isRsc\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n        this.basePath = basePath;\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            this.locales = locales;\n            this.defaultLocale = defaultLocale;\n            this.domainLocales = domainLocales;\n            this.isLocaleDomain = !!detectDomainLocale(domainLocales, self.location.hostname);\n        }\n        this.state = {\n            route,\n            pathname: pathname1,\n            query: query1,\n            asPath: autoExportDynamic ? pathname1 : as1,\n            isPreview: !!isPreview,\n            locale: process.env.__NEXT_I18N_SUPPORT ? locale : undefined,\n            isFallback\n        };\n        if (typeof window !== 'undefined') {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as1.startsWith('//')) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                options._shouldResolveHref = as1 !== pathname1;\n                this.changeState('replaceState', (0, _formatUrl).formatWithValidation({\n                    pathname: addBasePath(pathname1),\n                    query: query1\n                }), (0, _utils).getURL(), options);\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (process.env.__NEXT_SCROLL_RESTORATION) {\n                if (manualScrollRestoration) {\n                    window.history.scrollRestoration = 'manual';\n                }\n            }\n        }\n    }\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options = {}) {\n        if (process.env.__NEXT_SCROLL_RESTORATION) {\n            // TODO: remove in the future when we update history before route change\n            // is complete, as the popstate event should handle this capture.\n            if (manualScrollRestoration) {\n                try {\n                    // Snapshot scroll position right before navigating to a new page:\n                    sessionStorage.setItem('__next_scroll_' + this._idx, JSON.stringify({\n                        x: self.pageXOffset,\n                        y: self.pageYOffset\n                    }));\n                } catch  {}\n            }\n        }\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options = {}) {\n        ({ url , as  } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    async change(method, url, as, options, forcedScroll) {\n        if (!isLocalURL(url)) {\n            window.location.href = url;\n            return false;\n        }\n        const shouldResolveHref = options._h || options._shouldResolveHref || pathNoQueryHash(url) === pathNoQueryHash(as);\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        if (options._h) {\n            this.isReady = true;\n        }\n        const prevLocale = nextState.locale;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;\n            if (typeof options.locale === 'undefined') {\n                options.locale = nextState.locale;\n            }\n            const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(hasBasePath(as) ? delBasePath(as) : as);\n            const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n            if (localePathResult.detectedLocale) {\n                nextState.locale = localePathResult.detectedLocale;\n                parsedAs.pathname = addBasePath(parsedAs.pathname);\n                as = (0, _formatUrl).formatWithValidation(parsedAs);\n                url = addBasePath((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(url) ? delBasePath(url) : url, this.locales).pathname);\n            }\n            let didNavigate = false;\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                var ref;\n                // if the locale isn't configured hard navigate to show 404 page\n                if (!((ref = this.locales) === null || ref === void 0 ? void 0 : ref.includes(nextState.locale))) {\n                    parsedAs.pathname = addLocale(parsedAs.pathname, nextState.locale);\n                    window.location.href = (0, _formatUrl).formatWithValidation(parsedAs);\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            const detectedDomain = detectDomainLocale(this.domainLocales, undefined, nextState.locale);\n            // we need to wrap this in the env check again since regenerator runtime\n            // moves this on its own due to the return\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                // if we are navigating to a domain locale ensure we redirect to the\n                // correct domain\n                if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {\n                    const asNoBasePath = delBasePath(as);\n                    window.location.href = `http${detectedDomain.http ? '' : 's'}://${detectedDomain.domain}${addBasePath(`${nextState.locale === detectedDomain.defaultLocale ? '' : `/${nextState.locale}`}${asNoBasePath === '/' ? '' : asNoBasePath}` || '/')}`;\n                    // this was previously a return but was removed in favor\n                    // of better dead code elimination with regenerator runtime\n                    didNavigate = true;\n                }\n            }\n            if (didNavigate) {\n                return new Promise(()=>{});\n            }\n        }\n        if (!options._h) {\n            this.isSsr = false;\n        }\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark('routeChange');\n        }\n        const { shallow =false , scroll =true  } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute) {\n            this.abortComponentLoad(this._inFlightRoute, routeProps);\n        }\n        as = addBasePath(addLocale(hasBasePath(as) ? delBasePath(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = delLocale(hasBasePath(as) ? delBasePath(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        let localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        if (!options._h && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit('hashChangeStart', as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            this.set(nextState, this.components[nextState.route], null);\n            Router.events.emit('hashChangeComplete', as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n        let { pathname , query  } = parsed;\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            [pages, { __rewrites: rewrites  }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest(),\n                this.pageLoader.getMiddlewareList(), \n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            window.location.href = as;\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = 'replaceState';\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _normalizeTrailingSlash).removePathTrailingSlash(delBasePath(pathname)) : pathname;\n        if (shouldResolveHref && pathname !== '/_error') {\n            options._shouldResolveHref = true;\n            if (process.env.__NEXT_HAS_REWRITES && as.startsWith('/')) {\n                const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(cleanedAs, nextState.locale)), pages, rewrites, query, (p)=>resolveDynamicRoute(p, pages)\n                , this.locales);\n                if (rewritesResult.externalDest) {\n                    location.href = as;\n                    return true;\n                }\n                resolvedAs = rewritesResult.asPath;\n                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                    // if this directly matches a page we need to update the href to\n                    // allow the correct page chunk to be loaded\n                    pathname = rewritesResult.resolvedHref;\n                    parsed.pathname = addBasePath(pathname);\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                }\n            } else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = addBasePath(pathname);\n                    url = (0, _formatUrl).formatWithValidation(parsed);\n                }\n            }\n        }\n        if (!isLocalURL(as)) {\n            if (process.env.NODE_ENV !== 'production') {\n                throw new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`);\n            }\n            window.location.href = as;\n            return false;\n        }\n        resolvedAs = delLocale(delBasePath(resolvedAs), nextState.locale);\n        /**\n     * If the route update was triggered for client-side hydration and\n     * the rendered route is not dynamic do not check the preflight\n     * request as it is not necessary.\n     */ if ((!options.shallow || options._h === 1) && (options._h !== 1 || (0, _isDynamic).isDynamicRoute((0, _normalizeTrailingSlash).removePathTrailingSlash(pathname)))) {\n            const effect = await this._preflightRequest({\n                as,\n                cache: process.env.NODE_ENV === 'production',\n                pages,\n                pathname,\n                query,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview\n            });\n            if (effect.type === 'rewrite') {\n                query = {\n                    ...query,\n                    ...effect.parsedAs.query\n                };\n                resolvedAs = effect.asPath;\n                pathname = effect.resolvedHref;\n                parsed.pathname = effect.resolvedHref;\n                url = (0, _formatUrl).formatWithValidation(parsed);\n            } else if (effect.type === 'redirect' && effect.newAs) {\n                return this.change(method, effect.newUrl, effect.newAs, options);\n            } else if (effect.type === 'redirect' && effect.destination) {\n                window.location.href = effect.destination;\n                return new Promise(()=>{});\n            } else if (effect.type === 'refresh' && as !== window.location.pathname) {\n                window.location.href = as;\n                return new Promise(()=>{});\n            }\n        }\n        const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n        if ((0, _isDynamic).isDynamicRoute(route)) {\n            const parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeRegex).getRouteRegex(route);\n            const routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? interpolateAs(route, asPathname, query) : {};\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param]\n                );\n                if (missingParams.length > 0) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n                    }\n                    throw new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`);\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: omitParmsFromQuery(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        Router.events.emit('routeChangeStart', as, routeProps);\n        try {\n            var ref1, ref2;\n            let routeInfo = await this.getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, nextState.locale, nextState.isPreview);\n            let { error , props , __N_SSG , __N_SSP  } = routeInfo;\n            const component = routeInfo.Component;\n            if (component && component.unstable_scriptLoader) {\n                const scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach((script)=>{\n                    (0, _script).handleClientScriptLoad(script.props);\n                });\n            }\n            // handle redirect on client-transition\n            if ((__N_SSG || __N_SSP) && props) {\n                if (props.pageProps && props.pageProps.__N_REDIRECT) {\n                    const destination = props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith('/') && props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl , as: newAs  } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    window.location.href = destination;\n                    return new Promise(()=>{});\n                }\n                nextState.isPreview = !!props.__N_PREVIEW;\n                // handle SSG data 404\n                if (props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent('/404');\n                        notFoundRoute = '/404';\n                    } catch (_) {\n                        notFoundRoute = '/_error';\n                    }\n                    routeInfo = await this.getRouteInfo(notFoundRoute, notFoundRoute, query, as, resolvedAs, {\n                        shallow: false\n                    }, nextState.locale, nextState.isPreview);\n                }\n            }\n            Router.events.emit('beforeHistoryChange', as, routeProps);\n            this.changeState(method, url, as, options);\n            if (options._h && pathname === '/_error' && ((ref1 = self.__NEXT_DATA__.props) === null || ref1 === void 0 ? void 0 : (ref2 = ref1.pageProps) === null || ref2 === void 0 ? void 0 : ref2.statusCode) === 500 && (props === null || props === void 0 ? void 0 : props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                props.pageProps.statusCode = 500;\n            }\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === route;\n            var _scroll;\n            const shouldScroll = (_scroll = options.scroll) !== null && _scroll !== void 0 ? _scroll : !isValidShallowRoute;\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            await this.set({\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            }, routeInfo, forcedScroll !== null && forcedScroll !== void 0 ? forcedScroll : resetScroll).catch((e)=>{\n                if (e.cancelled) error = error || e;\n                else throw e;\n            });\n            if (error) {\n                Router.events.emit('routeChangeError', error, cleanedAs, routeProps);\n                throw error;\n            }\n            if (process.env.__NEXT_I18N_SUPPORT) {\n                if (nextState.locale) {\n                    document.documentElement.lang = nextState.locale;\n                }\n            }\n            Router.events.emit('routeChangeComplete', as, routeProps);\n            return true;\n        } catch (err1) {\n            if ((0, _isError).default(err1) && err1.cancelled) {\n                return false;\n            }\n            throw err1;\n        }\n    }\n    changeState(method, url, as, options = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (typeof window.history === 'undefined') {\n                console.error(`Warning: window.history is not available.`);\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(`Warning: window.history.${method} is not available`);\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils).getURL() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                idx: this._idx = method !== 'pushState' ? this._idx : this._idx + 1\n            }, // Most browsers currently ignores this parameter, although they may use it in the future.\n            // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n            Router.events.emit('routeChangeError', err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            window.location.href = as;\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        try {\n            let Component;\n            let styleSheets;\n            let props;\n            if (typeof Component === 'undefined' || typeof styleSheets === 'undefined') {\n                ({ page: Component , styleSheets  } = await this.fetchComponent('/_error'));\n            }\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error('Error in error page `getInitialProps`: ', gipErr);\n                    routeInfo.props = {};\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _isError).default(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + ''), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo(route, pathname, query, as, resolvedAs, routeProps, locale, isPreview) {\n        try {\n            const existingRouteInfo = this.components[route];\n            if (routeProps.shallow && existingRouteInfo && this.route === route) {\n                return existingRouteInfo;\n            }\n            let cachedRouteInfo = undefined;\n            // can only use non-initial route info\n            // cannot reuse route info in development since it can change after HMR\n            if (process.env.NODE_ENV !== 'development' && existingRouteInfo && !('initial' in existingRouteInfo)) {\n                cachedRouteInfo = existingRouteInfo;\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP,\n                    __N_RSC: !!res.mod.__next_rsc__\n                })\n            );\n            const { Component , __N_SSG , __N_SSP , __N_RSC  } = routeInfo;\n            if (process.env.NODE_ENV !== 'production') {\n                const { isValidElementType  } = require('next/dist/compiled/react-is');\n                if (!isValidElementType(Component)) {\n                    throw new Error(`The default export is not a React Component in page: \"${pathname}\"`);\n                }\n            }\n            let dataHref;\n            // For server components, non-SSR pages will have statically optimized\n            // flight data in a production build.\n            // So only development and SSR pages will always have the real-time\n            // generated and streamed flight data.\n            const useStreamedFlightData = (process.env.NODE_ENV !== 'production' || __N_SSP) && __N_RSC;\n            if (__N_SSG || __N_SSP || __N_RSC) {\n                dataHref = this.pageLoader.getDataHref({\n                    href: (0, _formatUrl).formatWithValidation({\n                        pathname,\n                        query\n                    }),\n                    asPath: resolvedAs,\n                    ssg: __N_SSG,\n                    flight: useStreamedFlightData,\n                    locale\n                });\n            }\n            const props = await this._getData(()=>(__N_SSG || __N_SSP || __N_RSC) && !useStreamedFlightData ? fetchNextData(dataHref, this.isSsr, false, __N_SSG ? this.sdc : this.sdr, !!__N_SSG && !isPreview) : this.getInitialProps(Component, // we provide AppTree later so this needs to be `any`\n                {\n                    pathname,\n                    query,\n                    asPath: as,\n                    locale,\n                    locales: this.locales,\n                    defaultLocale: this.defaultLocale\n                })\n            );\n            if (__N_RSC) {\n                if (useStreamedFlightData) {\n                    const { data  } = await this._getData(()=>this._getFlightData(dataHref)\n                    );\n                    props.pageProps = Object.assign(props.pageProps, {\n                        __flight__: data\n                    });\n                } else {\n                    const { __flight__  } = props;\n                    props.pageProps = Object.assign({}, props.pageProps, {\n                        __flight__\n                    });\n                }\n            }\n            routeInfo.props = props;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#');\n        const [newUrlNoHash, newHash] = as.split('#');\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = ''] = as.split('#');\n        // Scroll to top if the hash is just `#` with no value or `#top`\n        // To mirror browsers\n        if (hash === '' || hash === 'top') {\n            window.scrollTo(0, 0);\n            return;\n        }\n        // First we check if the element by id is found\n        const idEl = document.getElementById(hash);\n        if (idEl) {\n            idEl.scrollIntoView();\n            return;\n        }\n        // If there's no element with the id, we check the `name` property\n        // To mirror browsers\n        const nameEl = document.getElementsByName(hash)[0];\n        if (nameEl) {\n            nameEl.scrollIntoView();\n        }\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath = url, options = {}) {\n        let parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n        let { pathname , query  } = parsed;\n        if (process.env.__NEXT_I18N_SUPPORT) {\n            if (options.locale === false) {\n                pathname = (0, _normalizeLocalePath).normalizeLocalePath(pathname, this.locales).pathname;\n                parsed.pathname = pathname;\n                url = (0, _formatUrl).formatWithValidation(parsed);\n                let parsedAs = (0, _parseRelativeUrl).parseRelativeUrl(asPath);\n                const localePathResult = (0, _normalizeLocalePath).normalizeLocalePath(parsedAs.pathname, this.locales);\n                parsedAs.pathname = localePathResult.pathname;\n                options.locale = localePathResult.detectedLocale || this.defaultLocale;\n                asPath = (0, _formatUrl).formatWithValidation(parsedAs);\n            }\n        }\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith('/')) {\n            let rewrites;\n            ({ __rewrites: rewrites  } = await (0, _routeLoader).getClientBuildManifest());\n            const rewritesResult = (0, _resolveRewrites).default(addBasePath(addLocale(asPath, this.locale)), pages, rewrites, parsed.query, (p)=>resolveDynamicRoute(p, pages)\n            , this.locales);\n            if (rewritesResult.externalDest) {\n                return;\n            }\n            resolvedAs = delLocale(delBasePath(rewritesResult.asPath), this.locale);\n            if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                // if this directly matches a page we need to update the href to\n                // allow the correct page chunk to be loaded\n                pathname = rewritesResult.resolvedHref;\n                parsed.pathname = pathname;\n                url = (0, _formatUrl).formatWithValidation(parsed);\n            }\n        } else {\n            parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n            if (parsed.pathname !== pathname) {\n                pathname = parsed.pathname;\n                parsed.pathname = pathname;\n                url = (0, _formatUrl).formatWithValidation(parsed);\n            }\n        }\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (process.env.NODE_ENV !== 'production') {\n            return;\n        }\n        const effects = await this._preflightRequest({\n            as: addBasePath(asPath),\n            cache: true,\n            pages,\n            pathname,\n            query,\n            locale: this.locale,\n            isPreview: this.isPreview\n        });\n        if (effects.type === 'rewrite') {\n            parsed.pathname = effects.resolvedHref;\n            pathname = effects.resolvedHref;\n            query = {\n                ...query,\n                ...effects.parsedAs.query\n            };\n            resolvedAs = effects.asPath;\n            url = (0, _formatUrl).formatWithValidation(parsed);\n        }\n        const route = (0, _normalizeTrailingSlash).removePathTrailingSlash(pathname);\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData(this.pageLoader.getDataHref({\n                    href: url,\n                    asPath: resolvedAs,\n                    ssg: true,\n                    locale: typeof options.locale !== 'undefined' ? options.locale : this.locale\n                }), false, false, this.sdc, true) : false;\n            }),\n            this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route), \n        ]);\n    }\n    async fetchComponent(route) {\n        let cancelled = false;\n        const cancel = this.clc = ()=>{\n            cancelled = true;\n        };\n        const handleCancelled = ()=>{\n            if (cancelled) {\n                const error = new Error(`Abort fetching component for route: \"${route}\"`);\n                error.cancelled = true;\n                throw error;\n            }\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n        };\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error('Loading initial props cancelled');\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData(dataHref, true, true, this.sdc, false).then((serialized)=>{\n            return {\n                data: serialized\n            };\n        });\n    }\n    async _preflightRequest(options) {\n        const asPathname = pathNoQueryHash(options.as);\n        const cleanedAs = delLocale(hasBasePath(asPathname) ? delBasePath(asPathname) : asPathname, options.locale);\n        const fns = await this.pageLoader.getMiddlewareList();\n        const requiresPreflight = fns.some(([middleware, isSSR])=>{\n            return (0, _routeMatcher).getRouteMatcher((0, _getMiddlewareRegex).getMiddlewareRegex(middleware, !isSSR))(cleanedAs);\n        });\n        if (!requiresPreflight) {\n            return {\n                type: 'next'\n            };\n        }\n        const preflightHref = addLocale(options.as, options.locale);\n        let preflight;\n        try {\n            preflight = await this._getPreflightData({\n                preflightHref,\n                shouldCache: options.cache,\n                isPreview: options.isPreview\n            });\n        } catch (err) {\n            // If preflight request fails, we need to do a hard-navigation.\n            return {\n                type: 'redirect',\n                destination: options.as\n            };\n        }\n        if (preflight.rewrite) {\n            // for external rewrites we need to do a hard navigation\n            // to the resource\n            if (!preflight.rewrite.startsWith('/')) {\n                return {\n                    type: 'redirect',\n                    destination: options.as\n                };\n            }\n            const parsed = (0, _parseRelativeUrl).parseRelativeUrl((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.rewrite) ? delBasePath(preflight.rewrite) : preflight.rewrite, this.locales).pathname);\n            const fsPathname = (0, _normalizeTrailingSlash).removePathTrailingSlash(parsed.pathname);\n            let matchedPage;\n            let resolvedHref;\n            if (options.pages.includes(fsPathname)) {\n                matchedPage = true;\n                resolvedHref = fsPathname;\n            } else {\n                resolvedHref = resolveDynamicRoute(fsPathname, options.pages);\n                if (resolvedHref !== parsed.pathname && options.pages.includes(resolvedHref)) {\n                    matchedPage = true;\n                }\n            }\n            return {\n                type: 'rewrite',\n                asPath: parsed.pathname,\n                parsedAs: parsed,\n                matchedPage,\n                resolvedHref\n            };\n        }\n        if (preflight.redirect) {\n            if (preflight.redirect.startsWith('/')) {\n                const cleanRedirect = (0, _normalizeTrailingSlash).removePathTrailingSlash((0, _normalizeLocalePath).normalizeLocalePath(hasBasePath(preflight.redirect) ? delBasePath(preflight.redirect) : preflight.redirect, this.locales).pathname);\n                const { url: newUrl , as: newAs  } = prepareUrlAs(this, cleanRedirect, cleanRedirect);\n                return {\n                    type: 'redirect',\n                    newUrl,\n                    newAs\n                };\n            }\n            return {\n                type: 'redirect',\n                destination: preflight.redirect\n            };\n        }\n        // For SSR requests, they will be handled like normal pages.\n        if (preflight.refresh && !preflight.ssr) {\n            return {\n                type: 'refresh'\n            };\n        }\n        return {\n            type: 'next'\n        };\n    }\n    _getPreflightData(params) {\n        const { preflightHref , shouldCache =false , isPreview  } = params;\n        const { href: cacheKey  } = new URL(preflightHref, window.location.href);\n        if (process.env.NODE_ENV === 'production' && !isPreview && shouldCache && this.sde[cacheKey]) {\n            return Promise.resolve(this.sde[cacheKey]);\n        }\n        return fetch(preflightHref, {\n            method: 'HEAD',\n            credentials: 'same-origin',\n            headers: {\n                'x-middleware-preflight': '1'\n            }\n        }).then((res)=>{\n            if (!res.ok) {\n                throw new Error(`Failed to preflight request`);\n            }\n            return {\n                cache: res.headers.get('x-middleware-cache'),\n                redirect: res.headers.get('Location'),\n                refresh: res.headers.has('x-middleware-refresh'),\n                rewrite: res.headers.get('x-middleware-rewrite'),\n                ssr: !!res.headers.get('x-middleware-ssr')\n            };\n        }).then((data)=>{\n            if (shouldCache && data.cache !== 'no-cache') {\n                this.sde[cacheKey] = data;\n            }\n            return data;\n        }).catch((err)=>{\n            delete this.sde[cacheKey];\n            throw err;\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App  } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils).loadGetInitialProps(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    abortComponentLoad(as, routeProps) {\n        if (this.clc) {\n            Router.events.emit('routeChangeError', buildCancellationError(), as, routeProps);\n            this.clc();\n            this.clc = null;\n        }\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n}\nexports.default = Router;\nRouter.events = (0, _mitt).default();\n\n//# sourceMappingURL=router.js.map"]},"metadata":{},"sourceType":"script"}
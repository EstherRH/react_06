{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.prepareDestination = prepareDestination;\n\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\n\nvar _escapeRegexp = require(\"../../escape-regexp\");\n\nvar _parseUrl = require(\"./parse-url\");\n\nfunction matchHas(req, has, query) {\n  const params = {};\n  const allMatch = has.every(hasItem => {\n    let value;\n    let key = hasItem.key;\n\n    switch (hasItem.type) {\n      case 'header':\n        {\n          key = key.toLowerCase();\n          value = req.headers[key];\n          break;\n        }\n\n      case 'cookie':\n        {\n          value = req.cookies[hasItem.key];\n          break;\n        }\n\n      case 'query':\n        {\n          value = query[key];\n          break;\n        }\n\n      case 'host':\n        {\n          const {\n            host\n          } = (req === null || req === void 0 ? void 0 : req.headers) || {}; // remove port from host if present\n\n          const hostname = host === null || host === void 0 ? void 0 : host.split(':')[0].toLowerCase();\n          value = hostname;\n          break;\n        }\n\n      default:\n        {\n          break;\n        }\n    }\n\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key)] = value;\n      return true;\n    } else if (value) {\n      const matcher = new RegExp(`^${hasItem.value}$`);\n      const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n\n      if (matches) {\n        if (Array.isArray(matches)) {\n          if (matches.groups) {\n            Object.keys(matches.groups).forEach(groupKey => {\n              params[groupKey] = matches.groups[groupKey];\n            });\n          } else if (hasItem.type === 'host' && matches[0]) {\n            params.host = matches[0];\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  });\n\n  if (allMatch) {\n    return params;\n  }\n\n  return false;\n}\n\nfunction compileNonPath(value, params) {\n  if (!value.includes(':')) {\n    return value;\n  }\n\n  for (const key of Object.keys(params)) {\n    if (value.includes(`:${key}`)) {\n      value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n    }\n  }\n\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*'); // the value needs to start with a forward-slash to be compiled\n  // correctly\n\n  return (0, _pathToRegexp).compile(`/${value}`, {\n    validate: false\n  })(params).slice(1);\n}\n\nfunction prepareDestination(args) {\n  const query = Object.assign({}, args.query);\n  delete query.__nextLocale;\n  delete query.__nextDefaultLocale;\n  let escapedDestination = args.destination;\n\n  for (const param of Object.keys({ ...args.params,\n    ...query\n  })) {\n    escapedDestination = escapeSegment(escapedDestination, param);\n  }\n\n  const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);\n  const destQuery = parsedDestination.query;\n  const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ''}`);\n  const destHostname = unescapeSegments(parsedDestination.hostname || '');\n  const destPathParamKeys = [];\n  const destHostnameParamKeys = [];\n  (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);\n  (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);\n  const destParams = [];\n  destPathParamKeys.forEach(key => destParams.push(key.name));\n  destHostnameParamKeys.forEach(key => destParams.push(key.name));\n  const destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {\n    validate: false\n  }); // update any params in query values\n\n  for (const [key1, strOrArray] of Object.entries(destQuery)) {\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key1] = strOrArray.map(value => compileNonPath(unescapeSegments(value), args.params));\n    } else {\n      destQuery[key1] = compileNonPath(unescapeSegments(strOrArray), args.params);\n    }\n  } // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n\n\n  let paramKeys = Object.keys(args.params).filter(name => name !== 'nextInternalLocale');\n\n  if (args.appendParamsToQuery && !paramKeys.some(key => destParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = args.params[key];\n      }\n    }\n  }\n\n  let newUrl;\n\n  try {\n    newUrl = destPathCompiler(args.params);\n    const [pathname, hash] = newUrl.split('#');\n    parsedDestination.hostname = destHostnameCompiler(args.params);\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n    }\n\n    throw err;\n  } // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n\n\n  parsedDestination.query = { ...query,\n    ...parsedDestination.query\n  };\n  return {\n    newUrl,\n    destQuery,\n    parsedDestination\n  };\n}\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */\n\n\nfunction getSafeParamName(paramName) {\n  let newParamName = '';\n\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i);\n\n    if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n    ) {\n        newParamName += paramName[i];\n      }\n  }\n\n  return newParamName;\n}\n\nfunction escapeSegment(str, segmentName) {\n  return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, 'g'), `__ESC_COLON_${segmentName}`);\n}\n\nfunction unescapeSegments(str) {\n  return str.replace(/__ESC_COLON_/gi, ':');\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/prepare-destination.ts"],"names":["matchHas","req","has","query","params","allMatch","every","hasItem","value","key","type","toLowerCase","headers","cookies","host","hostname","split","getSafeParamName","matcher","RegExp","matches","Array","isArray","slice","match","groups","Object","keys","forEach","groupKey","compileNonPath","includes","replace","compile","validate","prepareDestination","args","assign","__nextLocale","__nextDefaultLocale","escapedDestination","destination","param","escapeSegment","parsedDestination","parseUrl","destQuery","destPath","unescapeSegments","pathname","hash","destHostname","destPathParamKeys","destHostnameParamKeys","pathToRegexp","destParams","push","name","destPathCompiler","destHostnameCompiler","strOrArray","entries","map","paramKeys","filter","appendParamsToQuery","some","newUrl","search","err","message","Error","paramName","newParamName","i","length","charCode","charCodeAt","str","segmentName","escapeStringRegexp"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.matchHas = matchHas;\nexports.compileNonPath = compileNonPath;\nexports.prepareDestination = prepareDestination;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nvar _escapeRegexp = require(\"../../escape-regexp\");\nvar _parseUrl = require(\"./parse-url\");\nfunction matchHas(req, has, query) {\n    const params = {};\n    const allMatch = has.every((hasItem)=>{\n        let value;\n        let key = hasItem.key;\n        switch(hasItem.type){\n            case 'header':\n                {\n                    key = key.toLowerCase();\n                    value = req.headers[key];\n                    break;\n                }\n            case 'cookie':\n                {\n                    value = req.cookies[hasItem.key];\n                    break;\n                }\n            case 'query':\n                {\n                    value = query[key];\n                    break;\n                }\n            case 'host':\n                {\n                    const { host  } = (req === null || req === void 0 ? void 0 : req.headers) || {};\n                    // remove port from host if present\n                    const hostname = host === null || host === void 0 ? void 0 : host.split(':')[0].toLowerCase();\n                    value = hostname;\n                    break;\n                }\n            default:\n                {\n                    break;\n                }\n        }\n        if (!hasItem.value && value) {\n            params[getSafeParamName(key)] = value;\n            return true;\n        } else if (value) {\n            const matcher = new RegExp(`^${hasItem.value}$`);\n            const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n            if (matches) {\n                if (Array.isArray(matches)) {\n                    if (matches.groups) {\n                        Object.keys(matches.groups).forEach((groupKey)=>{\n                            params[groupKey] = matches.groups[groupKey];\n                        });\n                    } else if (hasItem.type === 'host' && matches[0]) {\n                        params.host = matches[0];\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    });\n    if (allMatch) {\n        return params;\n    }\n    return false;\n}\nfunction compileNonPath(value, params) {\n    if (!value.includes(':')) {\n        return value;\n    }\n    for (const key of Object.keys(params)){\n        if (value.includes(`:${key}`)) {\n            value = value.replace(new RegExp(`:${key}\\\\*`, 'g'), `:${key}--ESCAPED_PARAM_ASTERISKS`).replace(new RegExp(`:${key}\\\\?`, 'g'), `:${key}--ESCAPED_PARAM_QUESTION`).replace(new RegExp(`:${key}\\\\+`, 'g'), `:${key}--ESCAPED_PARAM_PLUS`).replace(new RegExp(`:${key}(?!\\\\w)`, 'g'), `--ESCAPED_PARAM_COLON${key}`);\n        }\n    }\n    value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, '\\\\$1').replace(/--ESCAPED_PARAM_PLUS/g, '+').replace(/--ESCAPED_PARAM_COLON/g, ':').replace(/--ESCAPED_PARAM_QUESTION/g, '?').replace(/--ESCAPED_PARAM_ASTERISKS/g, '*');\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    return (0, _pathToRegexp).compile(`/${value}`, {\n        validate: false\n    })(params).slice(1);\n}\nfunction prepareDestination(args) {\n    const query = Object.assign({}, args.query);\n    delete query.__nextLocale;\n    delete query.__nextDefaultLocale;\n    let escapedDestination = args.destination;\n    for (const param of Object.keys({\n        ...args.params,\n        ...query\n    })){\n        escapedDestination = escapeSegment(escapedDestination, param);\n    }\n    const parsedDestination = (0, _parseUrl).parseUrl(escapedDestination);\n    const destQuery = parsedDestination.query;\n    const destPath = unescapeSegments(`${parsedDestination.pathname}${parsedDestination.hash || ''}`);\n    const destHostname = unescapeSegments(parsedDestination.hostname || '');\n    const destPathParamKeys = [];\n    const destHostnameParamKeys = [];\n    (0, _pathToRegexp).pathToRegexp(destPath, destPathParamKeys);\n    (0, _pathToRegexp).pathToRegexp(destHostname, destHostnameParamKeys);\n    const destParams = [];\n    destPathParamKeys.forEach((key)=>destParams.push(key.name)\n    );\n    destHostnameParamKeys.forEach((key)=>destParams.push(key.name)\n    );\n    const destPathCompiler = (0, _pathToRegexp).compile(destPath, // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    {\n        validate: false\n    });\n    const destHostnameCompiler = (0, _pathToRegexp).compile(destHostname, {\n        validate: false\n    });\n    // update any params in query values\n    for (const [key1, strOrArray] of Object.entries(destQuery)){\n        // the value needs to start with a forward-slash to be compiled\n        // correctly\n        if (Array.isArray(strOrArray)) {\n            destQuery[key1] = strOrArray.map((value)=>compileNonPath(unescapeSegments(value), args.params)\n            );\n        } else {\n            destQuery[key1] = compileNonPath(unescapeSegments(strOrArray), args.params);\n        }\n    }\n    // add path params to query if it's not a redirect and not\n    // already defined in destination query or path\n    let paramKeys = Object.keys(args.params).filter((name)=>name !== 'nextInternalLocale'\n    );\n    if (args.appendParamsToQuery && !paramKeys.some((key)=>destParams.includes(key)\n    )) {\n        for (const key of paramKeys){\n            if (!(key in destQuery)) {\n                destQuery[key] = args.params[key];\n            }\n        }\n    }\n    let newUrl;\n    try {\n        newUrl = destPathCompiler(args.params);\n        const [pathname, hash] = newUrl.split('#');\n        parsedDestination.hostname = destHostnameCompiler(args.params);\n        parsedDestination.pathname = pathname;\n        parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`;\n        delete parsedDestination.search;\n    } catch (err) {\n        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n            throw new Error(`To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match`);\n        }\n        throw err;\n    }\n    // Query merge order lowest priority to highest\n    // 1. initial URL query values\n    // 2. path segment values\n    // 3. destination specified query values\n    parsedDestination.query = {\n        ...query,\n        ...parsedDestination.query\n    };\n    return {\n        newUrl,\n        destQuery,\n        parsedDestination\n    };\n}\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */ function getSafeParamName(paramName) {\n    let newParamName = '';\n    for(let i = 0; i < paramName.length; i++){\n        const charCode = paramName.charCodeAt(i);\n        if (charCode > 64 && charCode < 91 || charCode > 96 && charCode < 123 // a-z\n        ) {\n            newParamName += paramName[i];\n        }\n    }\n    return newParamName;\n}\nfunction escapeSegment(str, segmentName) {\n    return str.replace(new RegExp(`:${(0, _escapeRegexp).escapeStringRegexp(segmentName)}`, 'g'), `__ESC_COLON_${segmentName}`);\n}\nfunction unescapeSegments(str) {\n    return str.replace(/__ESC_COLON_/gi, ':');\n}\n\n//# sourceMappingURL=prepare-destination.js.map"]},"metadata":{},"sourceType":"script"}
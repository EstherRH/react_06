{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPathMatch = getPathMatch;\n\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\n\nfunction getPathMatch(path, options) {\n  const keys = [];\n  const regexp = (0, _pathToRegexp).pathToRegexp(path, keys, {\n    delimiter: '/',\n    sensitive: false,\n    strict: options === null || options === void 0 ? void 0 : options.strict\n  });\n  const matcher = (0, _pathToRegexp).regexpToFunction((options === null || options === void 0 ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n  /**\n  * A matcher function that will check if a given pathname matches the path\n  * given in the builder function. When the path does not match it will return\n  * `false` but if it does it will return an object with the matched params\n  * merged with the params provided in the second argument.\n  */\n\n  return (pathname, params) => {\n    const res = pathname == null ? false : matcher(pathname);\n\n    if (!res) {\n      return false;\n    }\n    /**\n    * If unnamed params are not allowed they must be removed from\n    * the matched parameters. path-to-regexp uses \"string\" for named and\n    * \"number\" for unnamed parameters.\n    */\n\n\n    if (options === null || options === void 0 ? void 0 : options.removeUnnamedParams) {\n      for (const key of keys) {\n        if (typeof key.name === 'number') {\n          delete res.params[key.name];\n        }\n      }\n    }\n\n    return { ...params,\n      ...res.params\n    };\n  };\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/path-match.ts"],"names":["getPathMatch","path","options","keys","regexp","pathToRegexp","delimiter","sensitive","strict","matcher","regexpToFunction","regexModifier","RegExp","source","flags","pathname","params","res","removeUnnamedParams","key","name"],"mappings":";;;;;QA2BgBA,Y,GAAAA,Y;;AA1Ba,IAAA,aAAmC,GAAA,OAAA,CAAA,mCAAA,CAAnC;;SA0BbA,Y,CAAaC,I,EAAcC,O,EAAmB;AAC5D,QAAMC,IAAI,GAAU,EAApB;AACA,QAAMC,MAAM,GAAA,CAAA,GAAGC,aAAH,EAAe,YAAf,CAAgBJ,IAAhB,EAAsBE,IAAtB,EAA4B;AACtCG,IAAAA,SAAS,EAAE,GAD2B;AAEtCC,IAAAA,SAAS,EAAE,KAF2B;AAGtCC,IAAAA,MAAM,EAAEN,OAAO,KAAA,IAAPA,IAAAA,OAAO,KAAA,KAAA,CAAPA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAEM;AAHqB,GAA5B,CAAZ;AAMA,QAAMC,OAAO,GAAA,CAAA,GAAGC,aAAH,EAAmB,gBAAnB,CAAmB,CAC9BR,OAAO,KAAA,IAAPA,IAAAA,OAAO,KAAA,KAAA,CAAPA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAES,aADqB,IAE1B,IAAIC,MAAJ,CAAWV,OAAO,CAACS,aAART,CAAsBE,MAAM,CAACS,MAA7BX,CAAX,EAAiDE,MAAM,CAACU,KAAxD,CAF0B,GAG1BV,MAHO,EAIXD,IAJW,CAAb;AAOA;;;;;AAAA;;AAMA,SAAM,CACJY,QADI,EAEJC,MAFI,KAGU;AACd,UAAMC,GAAG,GAAGF,QAAQ,IAAI,IAAZA,GAAmB,KAAnBA,GAA2BN,OAAO,CAACM,QAAD,CAA9C;;AACA,QAAE,CAAGE,GAAL,EAAU;AACR,aAAO,KAAP;AACD;AAED;;;;AAAA;;;AAKA,QAAIf,OAAO,KAAA,IAAPA,IAAAA,OAAO,KAAA,KAAA,CAAPA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAEgB,mBAAb,EAAkC;AAChC,WAAK,MAAMC,GAAX,IAAkBhB,IAAlB,EAAwB;AACtB,YAAI,OAAOgB,GAAG,CAACC,IAAX,KAAoB,QAAxB,EAAkC;AAChC,iBAAQH,GAAG,CAACD,MAAJC,CAAmBE,GAAG,CAACC,IAAvBH,CAAR;AACD;AACF;AACF;;AAED,WAAO,E,GAAKD,MAAL;SAAgBC,GAAG,CAACD;AAApB,KAAP;AACD,GAvBD;AAwBD","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getPathMatch = getPathMatch;\nvar _pathToRegexp = require(\"next/dist/compiled/path-to-regexp\");\nfunction getPathMatch(path, options) {\n    const keys = [];\n    const regexp = (0, _pathToRegexp).pathToRegexp(path, keys, {\n        delimiter: '/',\n        sensitive: false,\n        strict: options === null || options === void 0 ? void 0 : options.strict\n    });\n    const matcher = (0, _pathToRegexp).regexpToFunction((options === null || options === void 0 ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);\n    /**\n   * A matcher function that will check if a given pathname matches the path\n   * given in the builder function. When the path does not match it will return\n   * `false` but if it does it will return an object with the matched params\n   * merged with the params provided in the second argument.\n   */ return (pathname, params)=>{\n        const res = pathname == null ? false : matcher(pathname);\n        if (!res) {\n            return false;\n        }\n        /**\n     * If unnamed params are not allowed they must be removed from\n     * the matched parameters. path-to-regexp uses \"string\" for named and\n     * \"number\" for unnamed parameters.\n     */ if (options === null || options === void 0 ? void 0 : options.removeUnnamedParams) {\n            for (const key of keys){\n                if (typeof key.name === 'number') {\n                    delete res.params[key.name];\n                }\n            }\n        }\n        return {\n            ...params,\n            ...res.params\n        };\n    };\n}\n\n//# sourceMappingURL=path-match.js.map"]},"metadata":{},"sourceType":"script"}
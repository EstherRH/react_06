{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getParametrizedRoute = getParametrizedRoute;\nexports.getRouteRegex = getRouteRegex;\n\nvar _escapeRegexp = require(\"../../escape-regexp\");\n\nfunction parseParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n\n  const repeat = param.startsWith('...');\n\n  if (repeat) {\n    param = param.slice(3);\n  }\n\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\n\nfunction getParametrizedRoute(route) {\n  const segments = (route.replace(/\\/$/, '') || '/').slice(1).split('/');\n  const groups = {};\n  let groupIndex = 1;\n  const parameterizedRoute = segments.map(segment => {\n    if (segment.startsWith('[') && segment.endsWith(']')) {\n      const {\n        key,\n        optional,\n        repeat\n      } = parseParameter(segment.slice(1, -1));\n      groups[key] = {\n        pos: groupIndex++,\n        repeat,\n        optional\n      };\n      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n    } else {\n      return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n    }\n  }).join(''); // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n\n  if (typeof window === 'undefined') {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1; // builds a minimal routeKey using only a-z and minimal number of characters\n\n    const getSafeRouteKey = () => {\n      let routeKey = '';\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode);\n        routeKeyCharCode++;\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++;\n          routeKeyCharCode = 97;\n        }\n      }\n\n      return routeKey;\n    };\n\n    const routeKeys = {};\n    let namedParameterizedRoute = segments.map(segment => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1)); // replace any non-word characters since they can break\n        // the named regex\n\n        let cleanedKey = key.replace(/\\W/g, '');\n        let invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n\n        if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n          invalidKey = true;\n        }\n\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n      } else {\n        return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n      }\n    }).join('');\n    return {\n      parameterizedRoute,\n      namedParameterizedRoute,\n      groups,\n      routeKeys\n    };\n  }\n\n  return {\n    parameterizedRoute,\n    groups\n  };\n}\n\nfunction getRouteRegex(normalizedRoute) {\n  const result = getParametrizedRoute(normalizedRoute);\n\n  if ('routeKeys' in result) {\n    return {\n      re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n      groups: result.groups,\n      routeKeys: result.routeKeys,\n      namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`\n    };\n  }\n\n  return {\n    re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n    groups: result.groups\n  };\n}","map":{"version":3,"sources":["../../../../../shared/lib/router/utils/route-regex.ts"],"names":["parseParameter","param","optional","startsWith","endsWith","slice","repeat","key","getParametrizedRoute","route","segments","replace","split","groups","groupIndex","parameterizedRoute","map","segment","pos","escapeStringRegexp","join","window","routeKeyCharCode","routeKeyCharLength","getSafeRouteKey","routeKey","i","String","fromCharCode","routeKeys","namedParameterizedRoute","cleanedKey","invalidKey","length","isNaN","parseInt","getRouteRegex","normalizedRoute","result","re","RegExp","namedRegex"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.getParametrizedRoute = getParametrizedRoute;\nexports.getRouteRegex = getRouteRegex;\nvar _escapeRegexp = require(\"../../escape-regexp\");\nfunction parseParameter(param) {\n    const optional = param.startsWith('[') && param.endsWith(']');\n    if (optional) {\n        param = param.slice(1, -1);\n    }\n    const repeat = param.startsWith('...');\n    if (repeat) {\n        param = param.slice(3);\n    }\n    return {\n        key: param,\n        repeat,\n        optional\n    };\n}\nfunction getParametrizedRoute(route) {\n    const segments = (route.replace(/\\/$/, '') || '/').slice(1).split('/');\n    const groups = {};\n    let groupIndex = 1;\n    const parameterizedRoute = segments.map((segment)=>{\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n            const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n            groups[key] = {\n                pos: groupIndex++,\n                repeat,\n                optional\n            };\n            return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n        } else {\n            return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n        }\n    }).join('');\n    // dead code eliminate for browser since it's only needed\n    // while generating routes-manifest\n    if (typeof window === 'undefined') {\n        let routeKeyCharCode = 97;\n        let routeKeyCharLength = 1;\n        // builds a minimal routeKey using only a-z and minimal number of characters\n        const getSafeRouteKey = ()=>{\n            let routeKey = '';\n            for(let i = 0; i < routeKeyCharLength; i++){\n                routeKey += String.fromCharCode(routeKeyCharCode);\n                routeKeyCharCode++;\n                if (routeKeyCharCode > 122) {\n                    routeKeyCharLength++;\n                    routeKeyCharCode = 97;\n                }\n            }\n            return routeKey;\n        };\n        const routeKeys = {};\n        let namedParameterizedRoute = segments.map((segment)=>{\n            if (segment.startsWith('[') && segment.endsWith(']')) {\n                const { key , optional , repeat  } = parseParameter(segment.slice(1, -1));\n                // replace any non-word characters since they can break\n                // the named regex\n                let cleanedKey = key.replace(/\\W/g, '');\n                let invalidKey = false;\n                // check if the key is still invalid and fallback to using a known\n                // safe key\n                if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n                    invalidKey = true;\n                }\n                if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {\n                    invalidKey = true;\n                }\n                if (invalidKey) {\n                    cleanedKey = getSafeRouteKey();\n                }\n                routeKeys[cleanedKey] = key;\n                return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n            } else {\n                return `/${(0, _escapeRegexp).escapeStringRegexp(segment)}`;\n            }\n        }).join('');\n        return {\n            parameterizedRoute,\n            namedParameterizedRoute,\n            groups,\n            routeKeys\n        };\n    }\n    return {\n        parameterizedRoute,\n        groups\n    };\n}\nfunction getRouteRegex(normalizedRoute) {\n    const result = getParametrizedRoute(normalizedRoute);\n    if ('routeKeys' in result) {\n        return {\n            re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n            groups: result.groups,\n            routeKeys: result.routeKeys,\n            namedRegex: `^${result.namedParameterizedRoute}(?:/)?$`\n        };\n    }\n    return {\n        re: new RegExp(`^${result.parameterizedRoute}(?:/)?$`),\n        groups: result.groups\n    };\n}\n\n//# sourceMappingURL=route-regex.js.map"]},"metadata":{},"sourceType":"script"}